<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>手写一些原生方法</title>
    <link href="/2021/11/29/%E6%89%8B%E5%86%99%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95/"/>
    <url>/2021/11/29/%E6%89%8B%E5%86%99%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="javascript-原生方法的手写实现"><a href="#javascript-原生方法的手写实现" class="headerlink" title="javascript 原生方法的手写实现"></a>javascript 原生方法的手写实现</h1><p>这段时间比较闲，所以自己试着写一些方法的实现！</p><blockquote><p>我是为了图测试方便直接挂在了原型方法上，实际的开发工作中不推荐这么操作，会有很大风险，建议单独建一个工具库文件存贮！</p></blockquote><h2 id="数组篇-Array"><a href="#数组篇-Array" class="headerlink" title="数组篇(Array)"></a>数组篇(Array)</h2><blockquote><p>定义个测试数组</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">const testArrayData = [<br>    &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>, age: <span class="hljs-number">22</span>, gender: <span class="hljs-string">&#x27;男&#x27;</span> &#125;,<br>    &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;linda&#x27;</span>, age: <span class="hljs-number">23</span>, gender: <span class="hljs-string">&#x27;女&#x27;</span> &#125;,<br>    &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;amanda&#x27;</span>, age: <span class="hljs-number">27</span>, gender: <span class="hljs-string">&#x27;女&#x27;</span> &#125;,<br>    &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;joho&#x27;</span>, age: <span class="hljs-number">22</span>, gender: <span class="hljs-string">&#x27;男&#x27;</span> &#125;,<br>    &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;tuoni&#x27;</span>, age: <span class="hljs-number">22</span>, gender: <span class="hljs-string">&#x27;男&#x27;</span> &#125;,<br>];<br><br></code></pre></div></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>参数说明</p><ul><li>item 被遍历的当前项</li><li>index 当前索引值</li><li>arr 数组本身</li><li>return unfiled</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">Array.prototype.myForEach = <span class="hljs-keyword">function</span>(callback) &#123;<br>    <span class="hljs-keyword">for</span>(let i = <span class="hljs-number">0</span>; i &lt; this.length; i++) &#123;<br>        callback(this[i], i, this)<br>    &#125;<br>&#125;<br><br><span class="hljs-regexp">//</span> 测试用例<br>testArrayData.myForEach((k, v, arr) =&gt; &#123;<br>    console.log(k, v, arr)<br>&#125;)<br><br><span class="hljs-regexp">//</span> &#123;name: <span class="hljs-string">&quot;jack&quot;</span>, age: <span class="hljs-number">22</span>, gender: <span class="hljs-string">&quot;男&quot;</span>&#125; <span class="hljs-number">0</span> (<span class="hljs-number">5</span>) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;]<br><span class="hljs-regexp">//</span> &#123;name: <span class="hljs-string">&quot;linda&quot;</span>, age: <span class="hljs-number">23</span>, gender: <span class="hljs-string">&quot;女&quot;</span>&#125; <span class="hljs-number">1</span> (<span class="hljs-number">5</span>) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;]<br><span class="hljs-regexp">//</span> &#123;name: <span class="hljs-string">&quot;amanda&quot;</span>, age: <span class="hljs-number">27</span>, gender: <span class="hljs-string">&quot;女&quot;</span>&#125; <span class="hljs-number">2</span> (<span class="hljs-number">5</span>) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;]<br><span class="hljs-regexp">//</span> &#123;name: <span class="hljs-string">&quot;joho&quot;</span>, age: <span class="hljs-number">22</span>, gender: <span class="hljs-string">&quot;男&quot;</span>&#125; <span class="hljs-number">3</span> (<span class="hljs-number">5</span>) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;]<br><span class="hljs-regexp">//</span> &#123;name: <span class="hljs-string">&quot;tuoni&quot;</span>, age: <span class="hljs-number">22</span>, gender: <span class="hljs-string">&quot;男&quot;</span>&#125; <span class="hljs-number">4</span> (<span class="hljs-number">5</span>) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;]<br></code></pre></div></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>参数说明</p><ul><li>item 被遍历的当前项</li><li>index 当前索引值</li><li>arr 数组本身</li><li>被处理后的数组结果 arr</li></ul><p>返回值 被处理后的数组结果 arr</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myMap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<br>        callback(<span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>参数说明</p><ul><li>item 被便利的当前项</li><li>index 当前索引值</li><li>arr 数组本身</li></ul><p>返回值 包含通过所提供函数实现的测试的所有元素。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">Array.prototype.myFilter = function (callback) &#123;<br>    <span class="hljs-keyword">const</span> res = []<br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) &#123;<br>        callback(<span class="hljs-keyword">this</span>[i], i, <span class="hljs-keyword">this</span>) &amp;&amp; res.push(<span class="hljs-keyword">this</span>[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>参数说明</p><ul><li>item 被便利的当前项</li><li>index 当前索引值</li><li>arr 数组本身</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">Array.prototype.myEvery = function (callback) &#123;<br>    <span class="hljs-keyword">const</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) &#123;<br>        flag = callback(<span class="hljs-keyword">this</span>[i], i, <span class="hljs-keyword">this</span>)<br>        <span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>参数说明</p><ul><li>item 被便利的当前项</li><li>index 当前索引值</li><li>arr 数组本身</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">Array.prototype.mySome = function (callback) &#123;<br>    <span class="hljs-keyword">const</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) &#123;<br>        flag = callback(<span class="hljs-keyword">this</span>[i], i, <span class="hljs-keyword">this</span>)<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>参数说明</p><ul><li>item 被便利的当前项</li><li>index 当前索引值</li><li>arr 数组本身</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myReduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, initValue</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>, pre;<br>    <span class="hljs-keyword">if</span> (initValue) &#123;<br>        pre = initValue<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pre = <span class="hljs-built_in">this</span>[<span class="hljs-number">0</span>]<br>        start = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<br>        pre = callback(pre, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><p>参数说明</p><ul><li>item 被便利的当前项</li><li>index 当前索引值</li><li>arr 数组本身</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">Array.prototype.myFindIndex = function (callback) &#123;<br>    <span class="hljs-keyword">for</span> (let i = start; i &lt; <span class="hljs-keyword">this</span>.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(callback(<span class="hljs-keyword">this</span>[i], i, <span class="hljs-keyword">this</span>)) &#123;<br>            <span class="hljs-keyword">return</span> i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>参数说明</p><ul><li>item 被便利的当前项</li><li>index 当前索引值</li><li>arr 数组本身</li></ul><p>返回值  返回数组中满足提供的测试函数的第一个元素的值 否则返回undefined</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">Array.prototype.myFind = function (callback) &#123;<br>    <span class="hljs-keyword">for</span> (let i = start; i &lt; <span class="hljs-keyword">this</span>.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(callback(<span class="hljs-keyword">this</span>[i], i, <span class="hljs-keyword">this</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> undefined<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p>参数说明</p><ul><li>initValue 填充的值</li><li>start 开始的索引 默认为0</li><li>end 填充结束的索引位置 默认length</li></ul><p>返回值  用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">Array<span class="hljs-variable">.prototype</span><span class="hljs-variable">.myFill</span> = <span class="hljs-keyword">function</span> (value, start = <span class="hljs-number">0</span>, <span class="hljs-keyword">end</span>) &#123;<br>  <span class="hljs-keyword">end</span> = <span class="hljs-keyword">end</span> || <span class="hljs-keyword">this</span><span class="hljs-variable">.length</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; <span class="hljs-keyword">end</span>; i++) &#123;<br>      <span class="hljs-keyword">this</span>[i] = value<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="对象篇（Object）"><a href="#对象篇（Object）" class="headerlink" title="对象篇（Object）"></a>对象篇（Object）</h2><p>测试对象</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> testObject = &#123;<br>    name: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>    age: <span class="hljs-number">28</span>,<br>    gender: <span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h3><blockquote><p>用于把对象转为键值对数组</p></blockquote><figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog"><span class="hljs-symbol">Object</span>.prototype.myEntries = function (obj) &#123;<br>    const res = [];<br>    for(let key in obj) &#123;<br>        obj.hasOwnProperty(key) &amp;&amp; res.push([key, obj[key]])<br>    &#125;<br>    return res;<br>&#125;<br><br>console.log(<span class="hljs-symbol">Object</span>.myEntries(testObject))<br>// [ [ <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;jack&#x27;</span> ], [ <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">28</span> ], [ <span class="hljs-string">&#x27;gender&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span> ] ]<br><br></code></pre></div></td></tr></table></figure><h3 id="fromEntries"><a href="#fromEntries" class="headerlink" title="fromEntries"></a>fromEntries</h3><blockquote><p>作用和entries 相反  把数组转为对象</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">Object.prototype.myFromEntries(arr) &#123;<br>    const obj = &#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>        <span class="hljs-built_in">let</span> [<span class="hljs-built_in">key</span>, value] = arr;<br>        obj[<span class="hljs-built_in">key</span>] = value;<br>    &#125;<br>    <span class="hljs-built_in">return</span> obj;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><blockquote><p>把对象的key 处理成一个数组形式并返回</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.myKeys = <span class="hljs-function"><span class="hljs-title">fucntion</span>(<span class="hljs-params">obj</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>        <span class="hljs-keyword">if</span>(obj.hasOwnProperty(key) &amp;&amp; res.push(key));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><blockquote><p>把对象的value 处理成一个数组形式并返回</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.myValue = <span class="hljs-function"><span class="hljs-title">fucntion</span>(<span class="hljs-params">obj</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>        <span class="hljs-keyword">if</span>(obj.hasOwnProperty(key) &amp;&amp; res.push(obj[key]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="instanceOf"><a href="#instanceOf" class="headerlink" title="instanceOf"></a>instanceOf</h3><blockquote><p>判断对象a 是否经过b的原型链</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.myInstanceOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">father, child</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> fp = father.prototype;<br>    <span class="hljs-keyword">const</span> cp = child.__proto__;<br>    <span class="hljs-keyword">while</span>(cp) &#123;<br>        <span class="hljs-keyword">if</span> (cp === fp) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        cp = cp.__proto__<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><blockquote><p>多个对象合并成一个对象</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">Object.prototype.myAssign = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, <span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span> || target === <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeError(<span class="hljs-string">&#x27;Cannot convert undefined or null to object&#x27;</span>)<br>    &#125;<br>    target = Object(target)<br><br>    <span class="hljs-keyword">for</span> (let nextObj of args) &#123;<br>        <span class="hljs-keyword">for</span> (let key <span class="hljs-keyword">in</span> nextObj) &#123;<br>            nextObj.hasOwnProperty(key) &amp;&amp; (target[key] = nextObj[key])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="函数（Function）"><a href="#函数（Function）" class="headerlink" title="函数（Function）"></a>函数（Function）</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">Fucntion.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj, <span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    obj = obj || window<br>    <span class="hljs-keyword">const</span> fn = Symbol(); <span class="hljs-comment">// 防止方法重名</span><br>    obj[fn] = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">const</span> result = obj[fn](...args);<br>    <span class="hljs-keyword">delete</span> result[fn];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">return</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><blockquote><p>和call 的区别就是在传参的方式上做区别</p></blockquote><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">Function.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, args</span>)</span>&#123;<br>    obj = obj || window<br>    <span class="hljs-keyword">const</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> = <span class="hljs-title">Symbol</span>(<span class="hljs-params"></span>)</span>; <span class="hljs-comment">// 防止方法重名</span><br>    obj[<span class="hljs-function"><span class="hljs-keyword">fn</span>] = <span class="hljs-title">this</span></span>;<br>    <span class="hljs-keyword">const</span> result = obj[<span class="hljs-function"><span class="hljs-keyword">fn</span>](<span class="hljs-params">...args</span>)</span>;<br>    delete result[<span class="hljs-function"><span class="hljs-keyword">fn</span>]</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">Function.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj, args)</span> </span>&#123;<br>    obj = obj || window<br>    <span class="hljs-keyword">const</span> fn = Symbol(); <span class="hljs-comment">// 防止方法重名</span><br>    obj[fn] = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 缓存this上下文</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args2</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> self) &#123;<br>            <span class="hljs-keyword">this</span>[fn] = self;<br>            <span class="hljs-keyword">this</span>[fn](...[...args, ...innerArgs]);<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>[fn];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            obj[fn]([...args, ...args2]);<br>            <span class="hljs-keyword">delete</span> obj[fn];<br>        &#125;<br>    &#125;<br>    res.prototype = Object.create(<span class="hljs-keyword">this</span>.prototype);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><ul><li>接收一个Promise数组，数组中如有非Promise项，则此项当做成功</li><li>如果所有Promise都成功，则返回成功结果数组</li><li>如果有一个Promise失败，则返回这个失败结果</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> promisee<span class="hljs-constructor">All(<span class="hljs-params">promises</span>)</span> &#123;<br>    const result = <span class="hljs-literal">[]</span>;<br>    const count = <span class="hljs-number">0</span>;<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> =&gt; &#123;<br>        promises.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each((<span class="hljs-params">promise</span>, <span class="hljs-params">index</span>)</span> =&gt; &#123;<br>            const addData =<span class="hljs-function"> (<span class="hljs-params">index</span>, <span class="hljs-params">value</span>) =&gt;</span> &#123;<br>                result<span class="hljs-literal">[<span class="hljs-identifier">index</span>]</span> = value;<br>                count++;<br>                <span class="hljs-keyword">if</span>(promises.length &gt;= count) &#123;<br>                    resolve(result)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(promise instanceOf Promisee) &#123;<br>                promise.<span class="hljs-keyword">then</span>(res =&gt; &#123;<br>                    add<span class="hljs-constructor">Data(<span class="hljs-params">index</span>, <span class="hljs-params">res</span>)</span><br>                &#125;,<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> reject(err))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                add<span class="hljs-constructor">Data(<span class="hljs-params">index</span>, <span class="hljs-params">promise</span>)</span><br>            &#125;<br>        &#125;)<br>    &#125;)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>any与all相反</p><ul><li>接收一个Promise数组，数组中如有非Promise项，则此项当做成功</li><li>如果有一个Promise成功，则返回这个成功结果</li><li>如果所有Promise都失败，则报错<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myAny</span>(<span class="hljs-params">promises</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>        promises.forEach(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span>(promise instanceOf <span class="hljs-built_in">Promise</span>) &#123;<br>                prmise.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                    resolve(res)<br>                &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                    count++;<br>                    <span class="hljs-keyword">if</span>(promises.length == count) &#123;<br>                        reject(<span class="hljs-string">&quot;all promises where rejected!&quot;</span>)<br>                    &#125;<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                resolve(promise)<br>            &#125;<br>        &#125;)<br>    &#125;)<br>&#125;<br><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><ul><li>接收一个Promise数组，数组中如有非Promise项，则此项当做成功</li><li>哪个Promise最快得到结果，就返回那个结果，无论成功失败<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myRace</span>(<span class="hljs-params">promises</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        promises.forEach(<span class="hljs-function"><span class="hljs-params">promise</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span>(promise instanceOf <span class="hljs-built_in">Promise</span>) &#123;<br>                promise.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                    resolve(res)<br>                &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> reject(err))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                relove(promise)<br>            &#125;<br>        &#125;)<br>    &#125;)<br>&#125;<br><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h3><ul><li>接收一个Promise数组，数组中如有非Promise项，则此项当做成功</li><li>把每一个Promise的结果，集合成数组，返回<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> my<span class="hljs-constructor">AllSettles(<span class="hljs-params">promises</span>)</span> &#123;<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> =&gt; &#123;<br>        const res = <span class="hljs-literal">[]</span>;<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>        const addData =<span class="hljs-function"> (<span class="hljs-params">status</span>, <span class="hljs-params">value</span>, <span class="hljs-params">i</span>) =&gt;</span> &#123;<br>            res<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = &#123;<br>                status,<br>                value<br>            &#125;<br>            count++;<br>            <span class="hljs-keyword">if</span> (count<span class="hljs-operator"> === </span>promises.length) &#123;<br>                resolve(res);<br>            &#125;<br>        &#125;<br>        promises.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each((<span class="hljs-params">promise</span>, <span class="hljs-params">i</span>)</span> =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (promise instanceof MyPromise) &#123;<br>                promise.<span class="hljs-keyword">then</span>(res =&gt; &#123;<br>                    add<span class="hljs-constructor">Data(&#x27;<span class="hljs-params">fulfilled</span>&#x27;, <span class="hljs-params">res</span>, <span class="hljs-params">i</span>)</span>;<br>                &#125;,<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> &#123;<br>                    add<span class="hljs-constructor">Data(&#x27;<span class="hljs-params">rejected</span>&#x27;, <span class="hljs-params">err</span>, <span class="hljs-params">i</span>)</span>;<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                add<span class="hljs-constructor">Data(&#x27;<span class="hljs-params">fulfilled</span>&#x27;, <span class="hljs-params">promise</span>, <span class="hljs-params">i</span>)</span>;<br>            &#125;<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><ul><li>接收一个回调函数，但无参数接收</li><li>无论成功失败状态，都会执行finally</li><li>Promise 的静态方法<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    callback()<br>    <span class="hljs-keyword">return</span> res<br>  &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    callback()<br>    <span class="hljs-keyword">throw</span> err<br>  &#125;)<br>&#125;<br><br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>husky&amp;lint-staged构建代码检查工作流</title>
    <link href="/2021/11/26/husky&amp;lint-staged%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <url>/2021/11/26/husky&amp;lint-staged%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="使用husky-amp-lint-staged构建代码检查工作流"><a href="#使用husky-amp-lint-staged构建代码检查工作流" class="headerlink" title="使用husky&amp;lint-staged构建代码检查工作流"></a>使用husky&amp;lint-staged构建代码检查工作流</h1><p>在一些有一定规模的前端技术团队几乎都会使用<em>eslint</em>来对成员代码进行质量的基本校验。以此来保障编码规范的一致性。</p><h2 id="配置npm-script的eslint-命令的痛点"><a href="#配置npm-script的eslint-命令的痛点" class="headerlink" title="配置npm script的eslint 命令的痛点"></a>配置npm script的eslint 命令的痛点</h2><p>因为目前团队是配置了eslint 的npm script 命令。成员在提交代码前需要执行一遍npm run lint 对项目下目录进行校验。这样产生如下的问题。</p><ul><li>效率问题<br>假如我只是更改了一个文件 却需要对整个项目进行eslint。显然这不合适（由于当前的项目已经规模不小了，以至于执行一次命令往往需要等待几分钟时间，时间就是金钱啊~~）。设想是否可以只对已更改的文件进行lint 操作呢</li></ul><p><strong>答案是：利用git hooks + lint-staged</strong></p><h2 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h2><p>husky 是githooks-Git使用的挂钩，可以在执行commit和push 等操作时利用钩子执行一些操作。<br>它的原理其实是在隐藏文件.git 文件夹下的shell 脚本里。你如果会一些shell 语法 就可以利用这些脚本来做一些相关的钩子事件。由于是团队使用的，我这里使用了npm 的一个开源包，可以使用它配置<strong>package.json</strong>文件来达到执行钩子事件。<br>执行如下</p><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><ol><li>install husky<figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> husky -D<br></code></pre></div></td></tr></table></figure></li><li>Enable Git hooks<figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">npx husky <span class="hljs-keyword">install</span><br></code></pre></div></td></tr></table></figure></li><li>配置package.json 文件<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 在script 脚本里添加如下命令<br><span class="hljs-string">&quot;script&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;prepare&quot;</span>: <span class="hljs-string">&quot;husky install&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="添加一个hook-命令"><a href="#添加一个hook-命令" class="headerlink" title="添加一个hook 命令"></a>添加一个hook 命令</h3><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">//执行如下命令添加一个新的hook<br>npx husky <span class="hljs-keyword">add</span> .husky/pre-<span class="hljs-keyword">commit</span> &quot;npm run lint&quot; // “npm run lint”是<span class="hljs-keyword">commit</span> 操作后执行的操作，具体可去官网看更多的用法<br>git <span class="hljs-keyword">add</span> .husky/pre-<span class="hljs-keyword">commit</span><br></code></pre></div></td></tr></table></figure>然后试着添加一个commit<figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;test&quot;</span><br><br></code></pre></div></td></tr></table></figure>commit 之后就会执行<strong>npm run lint</strong>的命令</li></ol><p>husky 到此已经配置完毕</p><h2 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h2><h3 id="install-1"><a href="#install-1" class="headerlink" title="install"></a>install</h3><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -D lint-staged<br></code></pre></div></td></tr></table></figure><h3 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h3><figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog"><span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;src/**/*.&#123;js,vue&#125;&quot;</span>: [<br>        <span class="hljs-string">&quot;vue-cli-service lint&quot;</span>,<br>        <span class="hljs-string">&quot;git add&quot;</span><br>    ]<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>其他配置<br>可以配置自动修复和自动格式化，这个视情况个性化配置<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;src/**/*.&#123;js,vue&#125;&quot;</span>: [<br>        <span class="hljs-string">&quot;vue-cli-service lint --fix&quot;</span>, <span class="hljs-regexp">//</span> 自动修复<br>        <span class="hljs-string">&quot;prettier --write&quot;</span>, <span class="hljs-regexp">//</span> 格式化代码<br>        <span class="hljs-string">&quot;git add&quot;</span><br>    ]<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用JavaScript监听设备网络状况</title>
    <link href="/2021/06/22/%E4%BD%BF%E7%94%A8JavaScript%E7%9B%91%E5%90%AC%E8%AE%BE%E5%A4%87%E7%BD%91%E7%BB%9C%E7%8A%B6%E5%86%B5/"/>
    <url>/2021/06/22/%E4%BD%BF%E7%94%A8JavaScript%E7%9B%91%E5%90%AC%E8%AE%BE%E5%A4%87%E7%BD%91%E7%BB%9C%E7%8A%B6%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<p>最近项目上有一个监听设备网络状态的需求，完成需求之余在此记录一下吧！</p><h1 id="设备网络连接状态"><a href="#设备网络连接状态" class="headerlink" title="设备网络连接状态"></a>设备网络连接状态</h1><p>设备的联网状态可以 使用<code>navigator.onLine</code>的API拿到, 然后也可以监听全局的<code>online &amp; offline</code>来做一些事件反馈</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 设备联网状态<br>window.addEventListener(<span class="hljs-string">&#x27;online&#x27;</span>, <span class="hljs-keyword">function</span>() &#123;<br>  <span class="hljs-regexp">//</span> 你要做的事情<br>&#125;)<br><br><span class="hljs-regexp">//</span> 设备断开网络<br>window.addEventListener(<span class="hljs-string">&#x27;offline&#x27;</span>, <span class="hljs-keyword">function</span>() &#123;<br>  <span class="hljs-regexp">//</span> 你要做的事情<br>&#125;)<br><br></code></pre></div></td></tr></table></figure><h1 id="网络带宽测速"><a href="#网络带宽测速" class="headerlink" title="网络带宽测速"></a>网络带宽测速</h1><p>以下是收集到的三种测速方案</p><h2 id="1-图片测速"><a href="#1-图片测速" class="headerlink" title="1.图片测速"></a>1.图片测速</h2><p>  原理就是创建一个image 标签，通过加载的时长和图片的大小来计算出带宽<br>  <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> speedWidthImage = <span class="hljs-function">(<span class="hljs-params">imgUrl, fileSize</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> start = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">let</span> end = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;img&#x27;</span>);<br>      start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>      img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>          end = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>          <span class="hljs-keyword">const</span> speed = fileSize * <span class="hljs-number">1000</span> / (end - start)  <span class="hljs-comment">// 文件大小 / 加载的用的时长 得出带宽值</span><br>          resolve(speed);<br>      &#125;<br>      img.src = imgUrl;<br>  &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> err &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure></p><blockquote><p>但是这个方法有一个使用缺点就是，需要一个图片地址，还要有一个图片的size值，用起来稍麻烦了些！而且需要添加额外的请求头去禁止缓存，<br>  否则http请求被缓存了，自然测出的值也是不准确的。</p></blockquote><h2 id="2-使用ajax-模拟测速"><a href="#2-使用ajax-模拟测速" class="headerlink" title="2.使用ajax 模拟测速"></a>2.使用ajax 模拟测速</h2>  <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> speedWithAJAX = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> end = <span class="hljs-literal">null</span>;<br>    start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;<br>        end = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>        <span class="hljs-keyword">const</span> size = xhr.getResponseHeader(<span class="hljs-string">&#x27;Content-Length&#x27;</span>) / <span class="hljs-number">1024</span>;<br>        <span class="hljs-keyword">const</span> speed = size * <span class="hljs-number">1000</span> / (end - start)<br>        resolve(speed);<br>      &#125;<br>    &#125;<br>    xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, url);<br>    xhr.send();<br>  &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> err &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>这个方法要比图片的方便一些，只需要一个url 就可以了。可是和使用图片一样面临着被缓存的可能。需要添加http头禁止缓存以保证测试的结果正常</p></blockquote><h2 id="3-navigator-connection-downlink"><a href="#3-navigator-connection-downlink" class="headerlink" title="3.navigator.connection.downlink"></a>3.<code>navigator.connection.downlink</code></h2><p>  MDN这么解释的</p><blockquote><p>downlink 是 NetworkInformation 接口的一个只读属性，返回以Mb/s为单位的有效带宽，并保留该值为25kb/s的最接近的整数倍。该值基于最近监测的保持活跃连接的应用层吞吐量，排除了到私有地址空间的连接。当缺少最近的带宽测量数据时，该属性由底层连接技术属性决定。</p></blockquote><p>  返回单位是MB，直接可以使用了。。(<em>^▽^</em>)</p><p>  但是看看兼容性惨不忍睹😟<br>  <img src="https://cdn.jsdelivr.net/gh/HWcool/image-hosting@master/images/image.sp3m0t8t64w.png" alt="兼容性一览"></p><p>  基本上PC端Chrome 60+， 移动端直接没有…  可惜了呀！</p><p>  最后看到了一个<code>network-speed-test</code> 的npm 包，上述三种方案都已经封装好了，直接调用！美哉~</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于vue2项目的TS改造</title>
    <link href="/2021/05/31/%E5%9F%BA%E4%BA%8Evue2%E7%89%88%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%9A%84TS%E6%94%AF%E6%8C%81%E6%94%B9%E9%80%A0/"/>
    <url>/2021/05/31/%E5%9F%BA%E4%BA%8Evue2%E7%89%88%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%9A%84TS%E6%94%AF%E6%8C%81%E6%94%B9%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>typescript 是当今最热门的JavaScript工具之一。它的设计目标是大型的应用和项目，用它编译出来的JavaScript可以运行在任何浏览器上。</p></blockquote><p><em>Typescfipt 以下简称为TS</em></p><p><code>TS能够给JavaScript添加特性的语言扩展，类型推断、类型批注和编译时检查、接口、枚举... 等等，要知道这些都是一些强类型语言才有的语法支持。</code></p><p>其实早在2年前博主就关注了TS，也做了一些简单的<a href="https://www.jianshu.com/p/ade84aebec76%22">学习笔记</a>。其实很想在项目上试试手的，奈何也是当时项目的进度和一些其他原因才放弃。最近有些时间，所以想把公司中的项目改造一下，前后也做了一些调查和笔记，在此记录一下。</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>在vue-cli4中使用typscript 需要安装一下两个依赖<code>vue-class-component</code>和<code>vue-property-decorator</code></p><figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene">yarn <span class="hljs-keyword">add</span> vue-<span class="hljs-keyword">class</span>-component vue-<span class="hljs-keyword">property</span>-decorator<br>或者<br>npm i vue-<span class="hljs-keyword">class</span>-component vue-<span class="hljs-keyword">property</span>-decorator<br></code></pre></div></td></tr></table></figure><blockquote><p>vue-property-decorator 是依赖于vue-class-component<br>vue-property-decorator提供了一些vue的装饰器写法</p></blockquote><p>改造工作正式开始</p><ol><li><p>更改入口文件<br>将项目下的<code>main.js</code> 为<code>main.ts</code></p></li><li><p>增加tsconfig.json<br>在项目的根目录下增加tsconfig.json的文件如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;esnext&quot;</span>,<br>    <span class="hljs-attr">&quot;module&quot;</span>: <span class="hljs-string">&quot;esnext&quot;</span>,<br>    <span class="hljs-attr">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;importHelpers&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;moduleResolution&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,<br>    <span class="hljs-attr">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;esModuleInterop&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>,<br>    <span class="hljs-attr">&quot;allowJs&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;noEmit&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;types&quot;</span>: [<span class="hljs-string">&quot;webpack-env&quot;</span>],<br>    <span class="hljs-attr">&quot;paths&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;@/*&quot;</span>: [<span class="hljs-string">&quot;src/*&quot;</span>]<br>    &#125;,<br>    <span class="hljs-attr">&quot;lib&quot;</span>: [<span class="hljs-string">&quot;esnext&quot;</span>, <span class="hljs-string">&quot;dom&quot;</span>, <span class="hljs-string">&quot;dom.iterable&quot;</span>, <span class="hljs-string">&quot;scripthost&quot;</span>]<br>  &#125;,<br>  <span class="hljs-attr">&quot;exclude&quot;</span>: [<span class="hljs-string">&quot;node_modules&quot;</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>tsconfig.json文件是当前项目的TS编译配置文件<br>具体作用可以看下<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html">官方的解释文件</a></p></li><li><p>新增shims-vue.d.ts<br>在src目录下增加<code>shims-vue.d.ts</code>文件，内容如下</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&quot;*.vue&quot;</span> &#123;<br>  <span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Vue;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>这个文件的主要作用是让TS认识所有的<code>*.vue</code>的文件。 </p></li><li><p>改造所有<code>.vue</code>的文件结构，使用vue-property-decorator的装饰器写法</p><ol><li><code>&lt;script&gt;替换为&lt;script lang=&quot;ts&quot;&gt;</code><br>　   加上 lang=ts 可以让webpack识别此段代码为 typescript</li><li>把原来的代码更改成vue-property-decorator支持的语法就可以啦</li></ol></li></ol><p>  下边是一个demo供参考<br>  <figure class="highlight handlebars"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    foo:</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">foo</span>&#125;&#125;</span><br><span class="xml">    defaultArg:</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">defaultArg</span>&#125;&#125;</span><span class="xml"> | </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">countplus</span>&#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;delToCount($event)&quot;</span>&gt;</span>点击del emit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">HellowWordComponent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HellowWordComponent</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aButton&quot;</span>&gt;</span>ref<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span></span><br><span class="xml">import &#123; Component, Vue, Prop, Emit, Ref &#125; from &#x27;vue-property-decorator&#x27;;</span><br><span class="xml">import HellowWordComponent from &#x27;@/components/HellowWordComponent.vue&#x27;;</span><br><br><span class="xml">@Component(&#123;</span><br><span class="xml">  components: &#123;</span><br><span class="xml">    HellowWordComponent,</span><br><span class="xml">  &#125;,</span><br><span class="xml">  beforeRouteLeave(to: any, from: any, next: any) &#123;</span><br><span class="xml">    console.log(&#x27;beforeRouteLeave&#x27;);</span><br><span class="xml">    next();</span><br><span class="xml">  &#125;,</span><br><span class="xml">  beforeRouteEnter(to: any, from: any, next: any) &#123;</span><br><span class="xml">    console.log(&#x27;beforeRouteLeave&#x27;);</span><br><span class="xml">    next();</span><br><span class="xml">  &#125;,</span><br><span class="xml">&#125;)</span><br><br><span class="xml">export default class DemoComponent extends Vue &#123;</span><br><span class="xml">  private foo = &#x27;App Foo!&#x27;;</span><br><br><span class="xml">  private count: number = this.$store.state.count;</span><br><br><span class="xml">  @Prop(Boolean) private defaultArg: string | undefined;</span><br><br><span class="xml">  @Emit(&#x27;delemit&#x27;) private delEmitClick(event: MouseEvent) &#123;&#125;</span><br><br><span class="xml">  @Ref(&#x27;aButton&#x27;) readonly ref!: HTMLButtonElement;</span><br><br><span class="xml">  // computed;</span><br><span class="xml">  get countplus () &#123;</span><br><span class="xml">    return this.count;</span><br><span class="xml">  &#125;</span><br><br><span class="xml">  created() &#123;&#125;</span><br><br><span class="xml">  mounted() &#123;&#125;</span><br><br><span class="xml">  beforeDestroy() &#123;&#125;</span><br><br><span class="xml">  public delToCount(event: MouseEvent) &#123;</span><br><span class="xml">    this.delEmitClick(event);</span><br><span class="xml">    this.count += 1; // countplus 会累加</span><br><span class="xml">  &#125;</span><br><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><br>  一下是几个常用的装饰器</p><ul><li>@Components</li><li>@Prop</li><li>@Emit</li><li>@Ref</li><li>@Watch</li><li>@Provide+@Inject</li><li>@Model</li><li>其他的</li></ul><h2 id="碰到的坑"><a href="#碰到的坑" class="headerlink" title="碰到的坑"></a>碰到的坑</h2><p>  因为现在市面不是所有的包依赖都支持ts版的，所以你在用的时候控制台会报一些这样的错误，会让刚玩的ts的同学有些找不到方向，比如我使用了<a href="https://cryptojs.gitbook.io/docs/">crypto-js</a>这个加密的库<br>  安装完依赖后，在项目中引用会报以下的错<br>  <img src="https://cdn.jsdelivr.net/gh/HWcool/image-hosting@master/images/image.igcozg0oweg.png" alt="报错信息"><br>  由于这个库文件中并没有声明<code>crypto-js</code>这样一个模块，所以ts编译器在读取的时候出现错误，这里有两种解决方案</p><ul><li><ol><li>直接在<code>shims-vue.d.ts</code>文件中增加声明模块<figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> <span class="hljs-string">&quot;crypto-js&quot;</span><span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure></li></ol></li><li><ol start="2"><li>或者安装它提示的<code>@/types/包名</code><br>这个方法不一定会管用，因为不一定会有这样的包出现供你使用</li></ol></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  大体上都是以上几个大的步骤，剩下的就是慢慢把项目中所有.js的文件更改为.ts文件后缀，然后按照TS语法重构一遍。<br>  总体上还是一个工作量不小的工程，但是TS上手了之后，再回头去看代码时，就会清晰很多，代码的健壮性也得到进一步提升！  </p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>tscript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个在线生成css 三角形的工具</title>
    <link href="/2021/05/20/%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E7%94%9F%E6%88%90css-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <url>/2021/05/20/%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E7%94%9F%E6%88%90css-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="css-triangle-generate"><a href="#css-triangle-generate" class="headerlink" title="css-triangle-generate"></a>css-triangle-generate</h1><p><img src="https://files.catbox.moe/6c9c72.png" alt="css-triangle-generate" title="三角形样式生成器"></p><p><a href="https://blog.hjplay.cn/css-triangle-generate/">在线预览地址</a></p><p>实现了如下的基本功能</p><ul><li>可调整三角形的高度</li><li>可调整三角形的宽度</li><li>可调整三角形的角度</li><li>可调整三角形的背景色</li></ul><p>使用了Vue3.0 版本 和ant-design 写的一个小玩意，具体也没啥好说的，比较简单功能的一个页面。主要是想体验下vue3.0版本的使用方法…</p><p>自vue3.0出来之后，一直没有用过，一部分是因为当前工作中事情比较多，另一方面是因为当前工作中使用vue2.0版本比较多的。这次就拿这个来试试手吧</p><p>也算对vue3的语法有个基本了解了吧</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动帮你找出package.json中未使用到的依赖项</title>
    <link href="/2021/05/14/%E8%87%AA%E5%8A%A8%E5%B8%AE%E4%BD%A0%E6%89%BE%E5%87%BApackage-json%E4%B8%AD%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9/"/>
    <url>/2021/05/14/%E8%87%AA%E5%8A%A8%E5%B8%AE%E4%BD%A0%E6%89%BE%E5%87%BApackage-json%E4%B8%AD%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="depcheck"><a href="#depcheck" class="headerlink" title="depcheck"></a>depcheck</h1><p> 一个中大型的项目通常会有很多的包依赖项，在维护这些项目时，如果想对项目做一些优化的动作时，对包依赖分析是一个必不可少的动作。<br> 但是对于上百个依赖项中手动查找出哪些用过，哪些没用过的就很头疼<br> <img src="https://files.catbox.moe/6e4tjz.jpeg"><br> 下边这个工具只要执行一行代码，就能自动帮你分析出哪些是没有用过的包。</p><p>  全局安装<br>  <figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">npm install depcheck -g<br><br><span class="hljs-comment">// 在你的项目目录下执行</span><br>depcheck<br><span class="hljs-comment">// 下边就是帮你分析出的结果</span><br>Unused dependencies<br><span class="hljs-comment">* underscore</span><br>Unused devDependencies<br><span class="hljs-comment">* jasmine</span><br>Missing dependencies<br><span class="hljs-comment">* lodash</span><br></code></pre></div></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何实现无限累加的一个函数</title>
    <link href="/2021/05/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%B4%AF%E5%8A%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0/"/>
    <url>/2021/05/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%B4%AF%E5%8A%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="关于这个文章"><a href="#关于这个文章" class="headerlink" title="关于这个文章"></a>关于这个文章</h2><p> 今天早上看了几页放了半个月的犀牛书，有去看了下函数的部分。下午的时候忽然看到这个标题了，就来写一下😁</p><h2 id="JavaScript-高阶函数-函数科里化"><a href="#JavaScript-高阶函数-函数科里化" class="headerlink" title="JavaScript 高阶函数  函数科里化"></a>JavaScript 高阶函数  函数科里化</h2><p> 这两个都是JavaScript函数的一些高阶使用方法的概念，具体的还是要在实践中慢慢去体会。言归正传，来实现一下这个面试题<br> 我在网上看到两个精妙的实现方法 来看看大佬们怎么实现的</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>这是一个叫山月的大佬的文章<a href="https://q.shanyue.tech/fe/js/428.html">文章地址</a></p><p>这是一个关于懒计算的函数，使用 sum 收集所有累加项，使用 valueOf 进行计算</p><ol><li>sum 返回一个函数，收集所有的累加项，使用递归实现</li><li>返回的函数带有 valueOf的方法，用于统一计算所有的值</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> f = (...rest) =&gt; sum(...args, ...rest)<br>  f.valueOf = () =&gt; args.reduce((x, y) =&gt; x + y, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> f<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>  这个大佬的写法也很佩服<a href="https://blog.csdn.net/sinat_36048532/article/details/109214580">地址</a><br>  具体代码如下<br>  <figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span><span class="hljs-params">(fn, <span class="hljs-rest_arg">...args1</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args2</span>)</span> </span>&#123;<br>    let allArgs = [...args1, ...args2];<br>    <span class="hljs-keyword">if</span>(args2.length === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 求和</span><br>      <span class="hljs-keyword">return</span> fn(...allArgs);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 柯里化收集参数</span><br>      <span class="hljs-keyword">return</span> curry(fn, ...allArgs);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>  let res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(let i of args) &#123;<br>      res += i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br>let add = curry(sum);<br>console.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)(<span class="hljs-number">7</span>)());<br></code></pre></div></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端的错误处理</title>
    <link href="/2021/05/10/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <url>/2021/05/10/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="我们的目标是什么？"><a href="#我们的目标是什么？" class="headerlink" title="我们的目标是什么？"></a>我们的目标是什么？</h3><p>将用户在使用网页服务时产生的影响用户体验的异常通过网络请求传回服务器，并进行可视化的展现，整个过程要求我们回传的错误信息包含错误类型、调用堆栈等错误信息以便开发人员定位错误。</p><h3 id="需上报的错误类型有几种？"><a href="#需上报的错误类型有几种？" class="headerlink" title="需上报的错误类型有几种？"></a>需上报的错误类型有几种？</h3><ol><li>静态资源加载失败</li><li>AJAX请求失败</li><li>JavaScript异常<ul><li>运行时报错<ul><li>同步错误</li><li>异步错误</li></ul></li><li>语法错误</li></ul></li><li>promise异常</li></ol><h3 id="捕获错误有几种方式？"><a href="#捕获错误有几种方式？" class="headerlink" title="捕获错误有几种方式？"></a>捕获错误有几种方式？</h3><p>这里我总结了几种，分别是：</p><ul><li>onerror全局监听</li><li>addEventListener全局监听</li><li>try…catch主动捕获</li><li>promise…catch主动捕获</li><li>重写<code>XMLHttpRequest</code>对象方法</li><li>MVVM框架例如VUE和React中的官方错误处理方法</li></ul><p>下面分别介绍：</p><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h4><p>使用方法大家应该都知道，使用try…catch可以主动的处理异常，养成在关键操作处写try…catch的习惯可以非常好的帮助后续判断线上遇到的各种异常。</p><p>这里需要指出try catch需要注意的几点：</p><ol><li><p>try-catch 只能捕获到同步的运行时错误，其他类型无法捕获</p><p><strong>解决方案：</strong> onerror都可以捕获到运行时的同步/异步错误</p></li></ol><h4 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h4><blockquote><p>当JavaScript运行时错误（包括语法错误）发生时，window会触发一个ErrorEvent接口的error事件，并执行window.onerror()。</p></blockquote><p>window.error可以用于全局捕获JavaScript产生的错误，使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123; <br>   <span class="hljs-comment">// message：错误信息（字符串）。</span><br>   <span class="hljs-comment">// source：发生错误的脚本URL（字符串）</span><br>   <span class="hljs-comment">// lineno：发生错误的行号（数字）</span><br>   <span class="hljs-comment">// colno：发生错误的列号（数字）</span><br>   <span class="hljs-comment">// error：Error对象（对象）</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是使用时需要注意几点：</p><ol><li><p><strong>Script Error</strong> </p><p>在单页面应用中，当我们使用script标签引入了JS文件，当该JS文件的来源域名和网页的域名不同时，这时如果该JS文件内部报错，则我们只能捕获到Script Error，而不是详细的错误信息，这是由于浏览器的跨域限制。</p><p><strong>解决方案：</strong></p><ul><li>需要在跨域的script标签中加入<code>crossorigin</code>属性，例如<code>&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot; crossorigin&gt;&lt;/script&gt;</code></li><li>需要给跨域资源的服务器的response header设置允许跨域：<code>Access-Control-Allow-Origin:*</code></li></ul></li><li><p>不能全局捕获到资源（如图片或脚本）的加载失败</p><p><strong>解决方案：</strong> 使用<code>window.addEventListener</code>捕获。</p></li><li><p>onerror无法捕获语法错误</p></li><li><p>onerror最好写在所有 JS 脚本的前面，否则有可能捕获不到错误</p></li></ol><h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h4><blockquote><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。这些error事件不会向上冒泡到window，不过（至少在Firefox中）能被单一的window.addEventListener捕获。</p></blockquote><p>使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(error);<br>&#125;, <span class="hljs-literal">true</span>)<br></code></pre></div></td></tr></table></figure><p><code>window.addEventListener</code>在运行时错误和资源加载错误时返回的错误对象不同，可以参考下面两图：</p><p>运行时错误：</p><p>资源加载错误：</p><p>使用时需要注意的点：</p><ol><li>不同浏览器下返回的error对象可能不同，需要注意兼容处理。</li><li>需要注意避免addEventListener重复监听。</li></ol><h4 id="promise-catch"><a href="#promise-catch" class="headerlink" title="promise catch"></a>promise catch</h4><p>在promise中使用catch可以非常方便的捕获到异步error，使用方法大家也应该都了解了。</p><p>这里说一下需要注意的点:</p><p>没有写catch的Promise中抛出的错误无法被onerror 或 try-catch捕获到，所以我们务必要在Promise中不要忘记写catch处理抛出的异常。</p><p>   <strong>解决方案：</strong> 为了防止有漏掉的Promise异常，建议在全局增加一个对<code>unhandledrejection</code>的监听，用来全局监听Uncaught Promise Error。使用方式：</p>   <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;unhandledrejection&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123; <br><span class="hljs-built_in">console</span>.log(e);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h4 id="重写XMLHttpRequest对象的方法"><a href="#重写XMLHttpRequest对象的方法" class="headerlink" title="重写XMLHttpRequest对象的方法"></a>重写<code>XMLHttpRequest</code>对象的方法</h4><p>该方法主要针对AJAX请求异常,附上参考代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> _self = <span class="hljs-built_in">this</span>;<br><br>        <span class="hljs-comment">// 重写 open</span><br>        XMLHttpRequest.prototype.open = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-comment">// 先在此处取得请求的url、method</span><br>            _self.reqUrl = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>];<br>            _self.reqMethod = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">// 在调用原生 open 实现重写</span><br>            _self.xhrOpen.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 重写 send</span><br>        XMLHttpRequest.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 记录xhr</span><br>            <span class="hljs-keyword">var</span> xhrmsg = &#123;<br>                <span class="hljs-string">&#x27;url&#x27;</span>: _self.reqUrl,<br>                <span class="hljs-string">&#x27;type&#x27;</span>: _self.reqMethod,<br>                <span class="hljs-comment">// 此处可以取得 ajax 的请求参数</span><br>                <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] || &#123;&#125;<br>            &#125;<br><br>            <span class="hljs-built_in">this</span>.addEventListener(<span class="hljs-string">&#x27;readystatechange&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.readyState === <span class="hljs-number">4</span>) &#123;<br>                    <span class="hljs-comment">// 此处可以取得一些响应信息</span><br>                    <span class="hljs-comment">// 响应信息</span><br>                    xhrmsg[<span class="hljs-string">&#x27;res&#x27;</span>] = <span class="hljs-built_in">this</span>.response;<br>                    xhrmsg[<span class="hljs-string">&#x27;status&#x27;</span>] = <span class="hljs-built_in">this</span>.status;<br>                    <span class="hljs-built_in">this</span>.status &gt;= <span class="hljs-number">200</span> &amp;&amp; <span class="hljs-built_in">this</span>.status &lt; <span class="hljs-number">400</span> ?<br>                        xhrmsg[<span class="hljs-string">&#x27;level&#x27;</span>] = <span class="hljs-string">&#x27;success&#x27;</span> : xhrmsg[<span class="hljs-string">&#x27;level&#x27;</span>] = <span class="hljs-string">&#x27;error&#x27;</span>;<br>                    xhrArray.push(xhrmsg);<br>                &#125;<br>            &#125;);<br><br>            _self.xhrSend.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="MVVM框架提供的错误处理钩子"><a href="#MVVM框架提供的错误处理钩子" class="headerlink" title="MVVM框架提供的错误处理钩子"></a>MVVM框架提供的错误处理钩子</h4><p>VUE和React都分别提供了对应的错误处理钩子，由于笔者使用VUE多一些，这里介绍一下VUE的错误处理：</p><p><strong>VUE官方文档介绍：</strong></p><blockquote><p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p><p> 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩溃。</p><p> 从 2.4.0 起这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。</p></blockquote><p>下面我们看一下实际情况：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;template&gt;<br>&lt;div @click=<span class="hljs-string">&quot;clickerror&quot;</span>&gt;error&lt;/div&gt;<br>&lt;/template&gt;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mounterror();<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">mounterror</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;抛出mount错误&quot;</span>);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">clickerror</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;抛出click错误&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Vue.config.errorHandler = <span class="hljs-function">(<span class="hljs-params">err, vm, info</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;通过vue errorHandler捕获的错误&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.error(err);<br>  <span class="hljs-built_in">console</span>.error(vm);<br>  <span class="hljs-built_in">console</span>.error(info);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到生命周期钩子里的错误是可以被errorHandler捕获到，但是当我们主动点击div触发clickerror时，会发现这时错误并没有被errorHandler捕获到，控制台输出的是Uncaught Error，也就是没有被捕获到的错误，所以需要注意的是，errorHandler方法目前还捕获不到绑定监听事件触发的异常，但是可以捕获到在生命周期钩子中调用的方法的错误。</p><p><strong>解决方案</strong> ：使用window.onerror</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;通过onerror捕获到的错误&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.error(message);<br>  <span class="hljs-built_in">console</span>.error(source);<br>  <span class="hljs-built_in">console</span>.error(lineno);<br>  <span class="hljs-built_in">console</span>.error(colno);<br>  <span class="hljs-built_in">console</span>.error(error);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在MVVM框架中使用onerror监听全局异常会发现并不能捕获到绑定事件的详细错误信息，只会输出Script Error，</p><p>这时我们可以尝试进入webpack配置，设置<code>devtool:&quot;source-map&quot;</code>,这时在控制台再次打印可以看见成功捕获到绑定事件的错误。</p><h3 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h3><p>两种主流上报方式：</p><ol><li><p>通过Ajax发送数据</p><p>因为Ajax请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建img标签的形式进行上报。</p></li><li><p>动态创建 img 标签的形式</p></li></ol><p><code>new Image().src = reportUrl + &#39;?msg=&#39; + msg;</code></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>错误处理</tag>
      
      <tag>错误上报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github高星的学习库</title>
    <link href="/2021/05/07/github%E9%AB%98%E6%98%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%BA%93/"/>
    <url>/2021/05/07/github%E9%AB%98%E6%98%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前端技术的变与不变"><a href="#前端技术的变与不变" class="headerlink" title="前端技术的变与不变"></a>前端技术的变与不变</h1><p>记录一些优质的github 学习资源。下面的都是一些前端领域极为优秀的学习资源。众所周知前端技术变化很快，但是我认为变的技术形态，不变的才是一个语言的核心。有空就翻翻这些优秀的库，巩固语言底层原理。掌握语言核心，轻松应对技术变化。</p><h1 id="优秀资源一览"><a href="#优秀资源一览" class="headerlink" title="优秀资源一览"></a>优秀资源一览</h1><h3 id="仓库1-JavaScript算法和数据结构"><a href="#仓库1-JavaScript算法和数据结构" class="headerlink" title="仓库1- JavaScript算法和数据结构"></a><span style="color: #faa043">仓库1- JavaScript算法和数据结构</span></h3><p>  <strong>star数： 106k</strong><br>  英文名：javascript-algorithms &amp; Data Structures 2020年 增长31.9K<br>  仓库地址：<a href="https://github.com/trekhleb/javascript-algorithms">https://github.com/trekhleb/javascript-algorithms</a><br>  <img src="https://files.catbox.moe/dgomf2.png" title="JavaScript算法和数据结构作者"><br>  该仓库包含了多种基于JavaScript的算法与数据结构。每种算法和数据结构都有自己的README，包含相关说明和链接，项目贴心的为你准备了中文版</p><p>  本，照顾英文不好的小伙伴。最主要的是还有相关的YouTube视频。</p><p>  YouTuBe视频地址:</p><p>  <a href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8</a></p><p>  就可以学习这些视频了，这些视频和仓库的学习资料一直在维护更新中，不用怕学到过时的知识。</p><h3 id="仓库2-Node-js最佳实践"><a href="#仓库2-Node-js最佳实践" class="headerlink" title="仓库2-Node.js最佳实践"></a><span style="color: #faa043">仓库2-Node.js最佳实践</span></h3><p>  <strong>star数 65k</strong><br>  英文名：Node bestpractices ，2020年增长 20.2k<br>  仓库地址：<a href="https://github.com/goldbergyoni/nodebestpractices">https://github.com/goldbergyoni/nodebestpractices</a><br><img src="https://files.catbox.moe/3d4t00.png" title="nodejs 最佳实践"><br>  这个算是Github上在Node.js 最佳实践 中排名最高的内容的总结和分享。</p><p>  他算是一个搜集总结，里边包括：项目结构实践、异常处理实践、编码规范实践、测试和总体质量实践、进入生产实践和安全实践。</p><p>  里边的内容一直都在更新，每周都有所增长，如果你想学习Node.js一定要关注这个仓库。</p><h3 id="仓库3-你不知道的JS"><a href="#仓库3-你不知道的JS" class="headerlink" title="仓库3-你不知道的JS"></a><span style="color: #faa043">仓库3-你不知道的JS</span></h3><p>  英文名：You-Dont-Know-JS , 2020年18K</p><p>  仓库地址:<a href="https://github.com/getify/You-Dont-Know-JS">https://github.com/getify/You-Dont-Know-JS</a></p><p>  <img src="https://files.catbox.moe/zn5hmm.png" title="你不知道的JS"><br>  如果你是一个前端，这本书是必看的，因为很多面试问题都会从这本书上出。我在这里简单举几个例子，比如什么是闭包、如何处理异步性能、作用域的相关知识…..熟读并掌握是最基本的要求了。</p><h3 id="仓库4-JavaScript代码整洁之道"><a href="#仓库4-JavaScript代码整洁之道" class="headerlink" title="仓库4- JavaScript代码整洁之道"></a><span style="color: #faa043">仓库4- JavaScript代码整洁之道</span></h3><p>  英文名：clean-code-javascript ， 年增长15.1K</p><p>  仓库地址：<a href="https://github.com/ryanmcdermott/clean-code-javascript">https://github.com/ryanmcdermott/clean-code-javascript</a><br>  <img src="https://files.catbox.moe/k2zffm.png" title="JavaScript代码整洁之道"><br>  这个项目的目的就是教会你如何写出更好的JavaScript代码，可以让人读懂的JavaScript代码。如果你已经是一名前端程序员，你会知道在实际开发中，我们阅读代码的时间会远远超过编写代码的时间，因此保证代码的可读性非常重要。</p><h3 id="仓库5-30秒代码"><a href="#仓库5-30秒代码" class="headerlink" title="仓库5-30秒代码"></a><span style="color: #faa043">仓库5-30秒代码</span></h3><p>  英文名：30 seconds of code ,年增长13.3K</p><p>  仓库地址：<a href="https://github.com/30-seconds/30-seconds-of-code">https://github.com/30-seconds/30-seconds-of-code</a><br>  <img src="https://files.catbox.moe/lb85ek.png" title="5-30秒代码"></p><p>  该项目里边都是开发时常用的简短代码，我开发时也经常从这里进行搬砖。更重要的是里边的代码编写的很经典。</p><p>  仓库把JavaScript代码按类别进行区分：数组、浏览器、日期、方法、计算、Node、对象和字符串类型，方便你平时使用的查找和学习。</p><p>  有些人为什么写的代码又快又好?也许并不是因为他单身多年，每日精进手速。往往只是知道一些你不知道的资源，这个项目就应该属于这一类型。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span style="color: #faa043">总结</span></h3><p>  编程这一行发展速度太快，每个月都有新的技术产生，不学习就会被淘汰。我因学习而焦虑，也因学习而充实。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习资源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端学习资源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识AST(抽象语法树)</title>
    <link href="/2021/05/07/%E5%AD%A6%E4%B9%A0AST-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"/>
    <url>/2021/05/07/%E5%AD%A6%E4%B9%A0AST-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="学习抽象语法树AST"><a href="#学习抽象语法树AST" class="headerlink" title="学习抽象语法树AST"></a>学习抽象语法树AST</h1><h2 id="AST概念"><a href="#AST概念" class="headerlink" title="AST概念"></a>AST概念</h2><blockquote><p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法架构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真是语法中出现的每个细节。比如嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；二类似于 if-condition-then这样的条件跳转语句，可以使用带有三个分支的节点来表示。<br>和抽象语法树相对的是具体语法树（通常称作分析树）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树，然后从分析树生成AST。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p></blockquote><p><img src="https://files.catbox.moe/y4ps45.png"></p><p>接下来我们将从概念性了解然后从一个实例中去一点点探索AST的神秘面纱</p><h2 id="什么是抽象语法树"><a href="#什么是抽象语法树" class="headerlink" title="什么是抽象语法树"></a>什么是抽象语法树</h2><p>在传统的编译语言的流程中，程序的一段源代码在执行之前会经历三个步骤,统称为<code>编译</code>:</p><ul><li>分词/词法分析阶段<br>这个过程会将由字符组成的字符串分解成有意义的代码块,这些代码块统称为词法单元(token).<br>举个例子: let a = 1,<br>这段程序通常会被分解成为下面这些词法单元:<br>let 、a、=、1、；<br>空格是否被当成此法单元，取决于空格在这门语言中的意义。</li><li>解析/语法分析<br>这个过程是将词法单元流转换成一个由元素嵌套所组成的代表了程序语法结构的树,这个树被称为<code>抽象语法树（abstract syntax code，AST)</code></li><li>代码生成<br>将AST转换成可执行代码的过程被称为代码生成.</li></ul><p>简单理解,就是把我们写的代码按照一定的规则转换成一种树形结构。<br>你可以到这个神奇的网站上看一下具体是如何转换成的<a href="https://astexplorer.net/">astexplorer</a><br><img src="https://files.catbox.moe/x4d0qa.png" alt="astexplorer" title="在线AST语法转换"></p><h2 id="AST的用途"><a href="#AST的用途" class="headerlink" title="AST的用途"></a>AST的用途</h2><p>AST的作用不仅仅是用来在JavaScript引擎的编译上，我们在实际的开发过程中也是经常使用的，比如我们常用的babel插件将 ES6转化成ES5、使用 UglifyJS来压缩代码 、css预处理器、开发WebPack插件、Vue-cli前端自动化工具等等，这些底层原理都是基于AST来实现的，AST能力十分强大， 能够帮助开发者理解JavaScript这门语言的精髓。</p><h2 id="AST的基础结构"><a href="#AST的基础结构" class="headerlink" title="AST的基础结构"></a>AST的基础结构</h2><p>我们在这个<a href="https://astexplorer.net/">在线转译AST</a> 的网址上输入一行简单的代码看一下</p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;jack&#x27;</span><br></code></pre></div></td></tr></table></figure><p>可以看到右边的转换后的AST结构是如下这样的<br><img src="https://files.catbox.moe/lpatwf.png" alt="转换后的AST"><br>json形式是这样的</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>  <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-number">199</span>,<br>  <span class="hljs-attr">&quot;body&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;VariableDeclaration&quot;</span>,<br>      <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-number">180</span>,<br>      <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-number">199</span>,<br>      <span class="hljs-attr">&quot;declarations&quot;</span>: [<br>        &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;VariableDeclarator&quot;</span>,<br>          <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-number">186</span>,<br>          <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-number">199</span>,<br>          <span class="hljs-attr">&quot;id&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;Identifier&quot;</span>,<br>            <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-number">186</span>,<br>            <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-number">190</span>,<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;name&quot;</span><br>          &#125;,<br>          <span class="hljs-attr">&quot;init&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;Literal&quot;</span>,<br>            <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-number">193</span>,<br>            <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-number">199</span>,<br>            <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;jack&quot;</span>,<br>            <span class="hljs-attr">&quot;raw&quot;</span>: <span class="hljs-string">&quot;&#x27;jack&#x27;&quot;</span><br>          &#125;<br>        &#125;<br>      ],<br>      <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;const&quot;</span><br>    &#125;<br>  ],<br>  <span class="hljs-attr">&quot;sourceType&quot;</span>: <span class="hljs-string">&quot;module&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以看到，一个标准的AST结构可以理解为一个json对象，那我们就可以通过一些方法去解析和操作它</p><h2 id="AST的编译过程"><a href="#AST的编译过程" class="headerlink" title="AST的编译过程"></a>AST的编译过程</h2><p>基本上AST的编译阶段如下<br><img src="https://files.catbox.moe/vla2lw.png" alt="AST编译阶段流程" title="AST编译阶段流程"></p><p>大致分为四个阶段</p><ol><li><p>词法分析scanner</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;jack&quot;</span><br></code></pre></div></td></tr></table></figure><p>在执行以上的代码时，在词法分析阶段，会对整段的代码进行扫描，生产tokens流<br>具体的tokens 流你可以在这个网址上看到<a href="https://esprima.org/demo/parse.html#">Esprima</a><br>如下图<br><img src="https://files.catbox.moe/j8zz67.png" alt="转化的tokens流" title="scanner扫描转化tokens流"></p></li><li><p>parser 生产AST<br>我们以上边的代码为例子，我们使用node 跑一下 感受下相关过程<br>首先初始化一个文件目录</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">mkdir</span> AST-<span class="hljs-keyword">test</span><br><span class="hljs-comment">// 进入目录</span><br><span class="hljs-keyword">cd</span>  AST-<span class="hljs-keyword">test</span><br><span class="hljs-comment">// 初始化一个node项目</span><br>npm init -y<br><span class="hljs-comment">// 这里我们使用esproma 去生成 首先安装相关依赖 命令行执行如下</span><br>npm i esprima --<span class="hljs-keyword">save</span><br><span class="hljs-comment">// 执行命令</span><br></code></pre></div></td></tr></table></figure><p>然后新建一个index.js 文件  并写入如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 新建文件</span><br>touch index.js<br><span class="hljs-comment">// 把如下代码写入index.js</span><br><span class="hljs-keyword">const</span> esproma = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esprima&#x27;</span>);<br><span class="hljs-keyword">let</span> code = <span class="hljs-string">&#x27;const name = &quot;jack&quot;&#x27;</span>;<br><span class="hljs-keyword">const</span> ast = esproma.parse(code);<br><span class="hljs-built_in">console</span>.log(ast);<br></code></pre></div></td></tr></table></figure><p>执行index.js</p><br>`node index.js`输出了如下的代码</li></ol><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">Script &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-symbol">&#x27;Program</span>&#x27;,<br>  <span class="hljs-keyword">body</span>: [<br>    VariableDeclaration &#123;<br>      <span class="hljs-keyword">type</span>: <span class="hljs-symbol">&#x27;VariableDeclaration</span>&#x27;,<br>      declarations: [<span class="hljs-keyword">Array</span>],<br>      kind: <span class="hljs-symbol">&#x27;const</span>&#x27;<br>    &#125;<br>  ],<br>  sourceType: <span class="hljs-symbol">&#x27;script</span>&#x27;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们现在就得到了一棵AST树</p><ol start="3"><li>traverse对AST树遍历,进行增删改查<br>这里使用estraverse去完成, 安装相关依赖 npm i estraverse –save<br>我们试着把上边的代码更改为<strong>const author = “mills han”</strong><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> esproma = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esprima&#x27;</span>);<br><span class="hljs-keyword">const</span> estraverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;estraverse&#x27;</span>);<br><span class="hljs-keyword">let</span> code = <span class="hljs-string">&#x27;const name = &quot;jack&quot;&#x27;</span>;<br><span class="hljs-keyword">const</span> ast = esproma.parse(code);<br>estraverse.traverse(ast, &#123;<br>  enter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>&#123;<br>    <span class="hljs-comment">// 更改代码</span><br>    node.name = <span class="hljs-string">&#x27;author&#x27;</span>;<br>    node.value = <span class="hljs-string">&#x27;mills han&#x27;</span><br>  &#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(ast);<br></code></pre></div></td></tr></table></figure></li></ol><p> 运行结果如下<br> <figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">Script &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;Program&#x27;</span>,<br>  body: [<br>    VariableDeclaration &#123;<br>      <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;VariableDeclaration&#x27;</span>,<br>      declarations: [<span class="hljs-keyword">Array</span>],<br>      kind: <span class="hljs-string">&#x27;const&#x27;</span>,<br>      <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;author&#x27;</span>,<br>      <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;mills han&#x27;</span><br>    &#125;<br>  ],<br>  sourceType: <span class="hljs-string">&#x27;script&#x27;</span>,<br>  <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;author&#x27;</span>,<br>  <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;mills han&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><br> 我们再执行的过程中就对原来的代码完成了遍历更新<br>4. generator将更新后的AST转化成代码<br>  这里我们使用escodegen去生成, 安装相关依赖 npm i escodegen –save<br>  在原来的代码基础上添加如下<br>  <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> escodegen = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;escodegen&#x27;</span>);<br><span class="hljs-comment">// codegen</span><br><span class="hljs-keyword">const</span> transformedCode = escodegen.generate(ast);<br><span class="hljs-built_in">console</span>.log(transformedCode);<br></code></pre></div></td></tr></table></figure></p><p>  输出如下<br>  <figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta">$ node <span class="hljs-keyword">index</span>.js<br><span class="hljs-keyword">const</span> author = <span class="hljs-string">&#x27;mills han&#x27;</span>;<br></code></pre></div></td></tr></table></figure><br>  好了！我们完成了对一段简单代码的AST编译过程</p><h2 id="AST在业务中的应用"><a href="#AST在业务中的应用" class="headerlink" title="AST在业务中的应用"></a>AST在业务中的应用</h2><p>  当前很多第三方的包依赖都会用到AST. 比如鼎鼎大名的 <strong>Babel</strong> </p><ul><li><a href="https://www.babeljs.cn/">Babel</a>是一个JavaScript的代码转换器，能把JavaScript的最新语法转译成浏览器兼容的语法。<br>Babel的三个主要处理步骤分别是： <strong>解析（parse），转换（transform），生成（generate）</strong>。</li><li>Vue.js<br>Vue.js 在它的编译模板过程中也会用到AST</li><li>等等其他</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>  AST抽象语法树的知识点作为JavaScript中(任何编程语言中都有ast这个概念,这里就不过多赘述)相对基础的，也是最不可忽略的知识，带给我们的启发是无限可能的，它就像一把螺丝刀，能够拆解javascript这台庞大的机器，让我们能够看到一些本质的东西，同时也能通过它批量构建任何javascript代码。</p>]]></content>
    
    
    <categories>
      
      <category>AST</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识Chrome-DevTools</title>
    <link href="/2021/04/21/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20Chrome%20%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/04/21/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20Chrome%20%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Chrome-DevToos"><a href="#Chrome-DevToos" class="headerlink" title="Chrome DevToos"></a>Chrome DevToos</h1><p>Chrome 是当今世界上使用最流行的浏览器<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827348caaefb08?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Chrome浏览器" title="浏览器使用率"></p><p>对于大部分人来说，Chrome 可能只是个浏览器，但是对于开发人员来说，它更是一个强大无比的工具，为了方便开发人员调试代码，主流的浏览器都内置了 DevTools， 身为一个天天跟浏览器打交道的前端攻城狮，熟悉浏览器调试是基本操作之一，掌握 Chrome 的调试技巧意味着效率直接的提高。</p><h3 id="如何打开Chrome-DevToos"><a href="#如何打开Chrome-DevToos" class="headerlink" title="如何打开Chrome DevToos"></a>如何打开Chrome DevToos</h3><ul><li><p>在 Chrome 菜单中选择 更多工具 &gt; 开发者工具</p></li><li><p>在页面元素上右键点击，选择 “检查”</p></li><li><p>使用 快捷键 Ctrl + Shift + I (Windows) 或 Cmd + Opt + I (Mac)</p></li></ul><h3 id="8大功能面板"><a href="#8大功能面板" class="headerlink" title="8大功能面板"></a>8大功能面板</h3><ol><li>元素面板</li><li>控制台面板</li><li>源代码面板</li><li>网络面板</li><li>性能面板</li><li>内存面板</li><li>应用面板</li><li>安全面板</li></ol><h4 id="1-element-元素面板"><a href="#1-element-元素面板" class="headerlink" title="1. element 元素面板"></a>1. element 元素面板</h4><p>调试DOM 元素 和css 样式来迭代布局和设计页面</p><ul><li>编辑DOM</li><li>编辑CSS样式</li><li>检查和调试样式</li></ul><p><img src="https://files.catbox.moe/bibmsn.png" alt="Elements面板" title="Elements面板"></p><h4 id="1-Console-控制台面板"><a href="#1-Console-控制台面板" class="headerlink" title="1. Console 控制台面板"></a>1. Console 控制台面板</h4><p>直接可以在上边运行代码段，在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为 shell 在页面上与 JavaScript 交互。<br><img src="https://files.catbox.moe/5l0bfo.png" alt="Console 面板" title="Console 面板"></p><h4 id="3-源代码面板"><a href="#3-源代码面板" class="headerlink" title="3.源代码面板"></a>3.源代码面板</h4><p>在源代码面板中设置断点来调试 JavaScript ，或者通过 Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器</p><ul><li>断点调试</li><li>调试混淆的代码</li><li>使用开发者工具的 Workspaces（工作区）进行持久化保存<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827446443e67ff?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="断点调试" title="断点调试"></li></ul><h4 id="4-网络面板"><a href="#4-网络面板" class="headerlink" title="4.网络面板"></a>4.网络面板</h4><p>使用网络面板了解请求和下载的资源文件并优化网页加载性能。</p><ul><li>网络面板基础</li><li>了解资源时间轴</li><li>网络带宽限制<br><img src="https://files.catbox.moe/ww07z7.png" alt="网络面板" title="网络面板"></li></ul><h4 id="5-性能面板"><a href="#5-性能面板" class="headerlink" title="5.性能面板"></a>5.性能面板</h4><p>使用时间轴面板可以通过记录和查看网站生命周期内发生的各种事件来提高页面的运行时性能。<br><img src="https://files.catbox.moe/m8h8y4.png" alt="性能面板图" title="性能面板"></p><h4 id="6-内存面板"><a href="#6-内存面板" class="headerlink" title="6.内存面板"></a>6.内存面板</h4><p>如果需要比时间轴面板提供的更多信息，可以使用“配置”面板，例如跟踪内存泄漏。</p><p>JavaScript CPU 分析器<br>内存堆区分析器<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827446210a9e18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h4 id="7-应用面板"><a href="#7-应用面板" class="headerlink" title="7.应用面板"></a>7.应用面板</h4><p>使用资源面板检查加载的所有资源，包括 IndexedDB 与 Web SQL 数据库，本地和会话存储，cookie ，应用程序缓存，图像，字体和样式表。</p><ul><li>管理数据<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827446eff22017?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></li></ul><h4 id="8-安全面板"><a href="#8-安全面板" class="headerlink" title="8.安全面板"></a>8.安全面板</h4><p>使用安全面板调试混合内容问题，证书问题等等。</p><p>安全<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827447112db421?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
