<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自动帮你找出package.json中未使用到的依赖项</title>
    <link href="/2021/05/14/%E8%87%AA%E5%8A%A8%E5%B8%AE%E4%BD%A0%E6%89%BE%E5%87%BApackage-json%E4%B8%AD%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9/"/>
    <url>/2021/05/14/%E8%87%AA%E5%8A%A8%E5%B8%AE%E4%BD%A0%E6%89%BE%E5%87%BApackage-json%E4%B8%AD%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="depcheck"><a href="#depcheck" class="headerlink" title="depcheck"></a>depcheck</h1><p> 一个中大型的项目通常会有很多的包依赖项，在维护这些项目时，如果想对项目做一些优化的动作时，对包依赖分析是一个必不可少的动作。<br> 但是对于上百个依赖项中手动查找出哪些用过，哪些没用过的就很头疼<br> <img src="https://files.catbox.moe/6e4tjz.jpeg"><br> 下边这个工具只要执行一行代码，就能自动帮你分析出哪些是没有用过的包。</p><p>  全局安装<br>  <figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">npm install depcheck -g<br><br><span class="hljs-comment">// 在你的项目目录下执行</span><br>depcheck<br><span class="hljs-comment">// 下边就是帮你分析出的结果</span><br>Unused dependencies<br><span class="hljs-comment">* underscore</span><br>Unused devDependencies<br><span class="hljs-comment">* jasmine</span><br>Missing dependencies<br><span class="hljs-comment">* lodash</span><br></code></pre></div></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何实现无限累加的一个函数</title>
    <link href="/2021/05/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%B4%AF%E5%8A%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0/"/>
    <url>/2021/05/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%B4%AF%E5%8A%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="关于这个文章"><a href="#关于这个文章" class="headerlink" title="关于这个文章"></a>关于这个文章</h2><p> 今天早上看了几页放了半个月的犀牛书，有去看了下函数的部分。下午的时候忽然看到这个标题了，就来写一下😁</p><h2 id="JavaScript-高阶函数-函数科里化"><a href="#JavaScript-高阶函数-函数科里化" class="headerlink" title="JavaScript 高阶函数  函数科里化"></a>JavaScript 高阶函数  函数科里化</h2><p> 这两个都是JavaScript函数的一些高阶使用方法的概念，具体的还是要在实践中慢慢去体会。言归正传，来实现一下这个面试题<br> 我在网上看到两个精妙的实现方法 来看看大佬们怎么实现的</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>这是一个叫山月的大佬的文章<a href="https://q.shanyue.tech/fe/js/428.html">文章地址</a></p><p>这是一个关于懒计算的函数，使用 sum 收集所有累加项，使用 valueOf 进行计算</p><ol><li>sum 返回一个函数，收集所有的累加项，使用递归实现</li><li>返回的函数带有 valueOf的方法，用于统一计算所有的值</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> f = (...rest) =&gt; sum(...args, ...rest)<br>  f.valueOf = () =&gt; args.reduce((x, y) =&gt; x + y, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> f<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>  这个大佬的写法也很佩服<a href="https://blog.csdn.net/sinat_36048532/article/details/109214580">地址</a><br>  具体代码如下<br>  <figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span><span class="hljs-params">(fn, <span class="hljs-rest_arg">...args1</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args2</span>)</span> </span>&#123;<br>    let allArgs = [...args1, ...args2];<br>    <span class="hljs-keyword">if</span>(args2.length === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 求和</span><br>      <span class="hljs-keyword">return</span> fn(...allArgs);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 柯里化收集参数</span><br>      <span class="hljs-keyword">return</span> curry(fn, ...allArgs);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>  let res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(let i of args) &#123;<br>      res += i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br>let add = curry(sum);<br>console.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)(<span class="hljs-number">7</span>)());<br></code></pre></div></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端的错误处理</title>
    <link href="/2021/05/10/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <url>/2021/05/10/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="我们的目标是什么？"><a href="#我们的目标是什么？" class="headerlink" title="我们的目标是什么？"></a>我们的目标是什么？</h3><p>将用户在使用网页服务时产生的影响用户体验的异常通过网络请求传回服务器，并进行可视化的展现，整个过程要求我们回传的错误信息包含错误类型、调用堆栈等错误信息以便开发人员定位错误。</p><h3 id="需上报的错误类型有几种？"><a href="#需上报的错误类型有几种？" class="headerlink" title="需上报的错误类型有几种？"></a>需上报的错误类型有几种？</h3><ol><li>静态资源加载失败</li><li>AJAX请求失败</li><li>JavaScript异常<ul><li>运行时报错<ul><li>同步错误</li><li>异步错误</li></ul></li><li>语法错误</li></ul></li><li>promise异常</li></ol><h3 id="捕获错误有几种方式？"><a href="#捕获错误有几种方式？" class="headerlink" title="捕获错误有几种方式？"></a>捕获错误有几种方式？</h3><p>这里我总结了几种，分别是：</p><ul><li>onerror全局监听</li><li>addEventListener全局监听</li><li>try…catch主动捕获</li><li>promise…catch主动捕获</li><li>重写<code>XMLHttpRequest</code>对象方法</li><li>MVVM框架例如VUE和React中的官方错误处理方法</li></ul><p>下面分别介绍：</p><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h4><p>使用方法大家应该都知道，使用try…catch可以主动的处理异常，养成在关键操作处写try…catch的习惯可以非常好的帮助后续判断线上遇到的各种异常。</p><p>这里需要指出try catch需要注意的几点：</p><ol><li><p>try-catch 只能捕获到同步的运行时错误，其他类型无法捕获</p><p><strong>解决方案：</strong> onerror都可以捕获到运行时的同步/异步错误</p></li></ol><h4 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h4><blockquote><p>当JavaScript运行时错误（包括语法错误）发生时，window会触发一个ErrorEvent接口的error事件，并执行window.onerror()。</p></blockquote><p>window.error可以用于全局捕获JavaScript产生的错误，使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123; <br>   <span class="hljs-comment">// message：错误信息（字符串）。</span><br>   <span class="hljs-comment">// source：发生错误的脚本URL（字符串）</span><br>   <span class="hljs-comment">// lineno：发生错误的行号（数字）</span><br>   <span class="hljs-comment">// colno：发生错误的列号（数字）</span><br>   <span class="hljs-comment">// error：Error对象（对象）</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是使用时需要注意几点：</p><ol><li><p><strong>Script Error</strong> </p><p>在单页面应用中，当我们使用script标签引入了JS文件，当该JS文件的来源域名和网页的域名不同时，这时如果该JS文件内部报错，则我们只能捕获到Script Error，而不是详细的错误信息，这是由于浏览器的跨域限制。</p><p><strong>解决方案：</strong></p><ul><li>需要在跨域的script标签中加入<code>crossorigin</code>属性，例如<code>&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot; crossorigin&gt;&lt;/script&gt;</code></li><li>需要给跨域资源的服务器的response header设置允许跨域：<code>Access-Control-Allow-Origin:*</code></li></ul></li><li><p>不能全局捕获到资源（如图片或脚本）的加载失败</p><p><strong>解决方案：</strong> 使用<code>window.addEventListener</code>捕获。</p></li><li><p>onerror无法捕获语法错误</p></li><li><p>onerror最好写在所有 JS 脚本的前面，否则有可能捕获不到错误</p></li></ol><h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h4><blockquote><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。这些error事件不会向上冒泡到window，不过（至少在Firefox中）能被单一的window.addEventListener捕获。</p></blockquote><p>使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(error);<br>&#125;, <span class="hljs-literal">true</span>)<br></code></pre></div></td></tr></table></figure><p><code>window.addEventListener</code>在运行时错误和资源加载错误时返回的错误对象不同，可以参考下面两图：</p><p>运行时错误：</p><p>资源加载错误：</p><p>使用时需要注意的点：</p><ol><li>不同浏览器下返回的error对象可能不同，需要注意兼容处理。</li><li>需要注意避免addEventListener重复监听。</li></ol><h4 id="promise-catch"><a href="#promise-catch" class="headerlink" title="promise catch"></a>promise catch</h4><p>在promise中使用catch可以非常方便的捕获到异步error，使用方法大家也应该都了解了。</p><p>这里说一下需要注意的点:</p><p>没有写catch的Promise中抛出的错误无法被onerror 或 try-catch捕获到，所以我们务必要在Promise中不要忘记写catch处理抛出的异常。</p><p>   <strong>解决方案：</strong> 为了防止有漏掉的Promise异常，建议在全局增加一个对<code>unhandledrejection</code>的监听，用来全局监听Uncaught Promise Error。使用方式：</p>   <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;unhandledrejection&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123; <br><span class="hljs-built_in">console</span>.log(e);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h4 id="重写XMLHttpRequest对象的方法"><a href="#重写XMLHttpRequest对象的方法" class="headerlink" title="重写XMLHttpRequest对象的方法"></a>重写<code>XMLHttpRequest</code>对象的方法</h4><p>该方法主要针对AJAX请求异常,附上参考代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> _self = <span class="hljs-built_in">this</span>;<br><br>        <span class="hljs-comment">// 重写 open</span><br>        XMLHttpRequest.prototype.open = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-comment">// 先在此处取得请求的url、method</span><br>            _self.reqUrl = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>];<br>            _self.reqMethod = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">// 在调用原生 open 实现重写</span><br>            _self.xhrOpen.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 重写 send</span><br>        XMLHttpRequest.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 记录xhr</span><br>            <span class="hljs-keyword">var</span> xhrmsg = &#123;<br>                <span class="hljs-string">&#x27;url&#x27;</span>: _self.reqUrl,<br>                <span class="hljs-string">&#x27;type&#x27;</span>: _self.reqMethod,<br>                <span class="hljs-comment">// 此处可以取得 ajax 的请求参数</span><br>                <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] || &#123;&#125;<br>            &#125;<br><br>            <span class="hljs-built_in">this</span>.addEventListener(<span class="hljs-string">&#x27;readystatechange&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.readyState === <span class="hljs-number">4</span>) &#123;<br>                    <span class="hljs-comment">// 此处可以取得一些响应信息</span><br>                    <span class="hljs-comment">// 响应信息</span><br>                    xhrmsg[<span class="hljs-string">&#x27;res&#x27;</span>] = <span class="hljs-built_in">this</span>.response;<br>                    xhrmsg[<span class="hljs-string">&#x27;status&#x27;</span>] = <span class="hljs-built_in">this</span>.status;<br>                    <span class="hljs-built_in">this</span>.status &gt;= <span class="hljs-number">200</span> &amp;&amp; <span class="hljs-built_in">this</span>.status &lt; <span class="hljs-number">400</span> ?<br>                        xhrmsg[<span class="hljs-string">&#x27;level&#x27;</span>] = <span class="hljs-string">&#x27;success&#x27;</span> : xhrmsg[<span class="hljs-string">&#x27;level&#x27;</span>] = <span class="hljs-string">&#x27;error&#x27;</span>;<br>                    xhrArray.push(xhrmsg);<br>                &#125;<br>            &#125;);<br><br>            _self.xhrSend.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="MVVM框架提供的错误处理钩子"><a href="#MVVM框架提供的错误处理钩子" class="headerlink" title="MVVM框架提供的错误处理钩子"></a>MVVM框架提供的错误处理钩子</h4><p>VUE和React都分别提供了对应的错误处理钩子，由于笔者使用VUE多一些，这里介绍一下VUE的错误处理：</p><p><strong>VUE官方文档介绍：</strong></p><blockquote><p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p><p> 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩溃。</p><p> 从 2.4.0 起这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。</p></blockquote><p>下面我们看一下实际情况：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;template&gt;<br>&lt;div @click=<span class="hljs-string">&quot;clickerror&quot;</span>&gt;error&lt;/div&gt;<br>&lt;/template&gt;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mounterror();<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">mounterror</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;抛出mount错误&quot;</span>);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">clickerror</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;抛出click错误&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Vue.config.errorHandler = <span class="hljs-function">(<span class="hljs-params">err, vm, info</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;通过vue errorHandler捕获的错误&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.error(err);<br>  <span class="hljs-built_in">console</span>.error(vm);<br>  <span class="hljs-built_in">console</span>.error(info);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到生命周期钩子里的错误是可以被errorHandler捕获到，但是当我们主动点击div触发clickerror时，会发现这时错误并没有被errorHandler捕获到，控制台输出的是Uncaught Error，也就是没有被捕获到的错误，所以需要注意的是，errorHandler方法目前还捕获不到绑定监听事件触发的异常，但是可以捕获到在生命周期钩子中调用的方法的错误。</p><p><strong>解决方案</strong> ：使用window.onerror</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;通过onerror捕获到的错误&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.error(message);<br>  <span class="hljs-built_in">console</span>.error(source);<br>  <span class="hljs-built_in">console</span>.error(lineno);<br>  <span class="hljs-built_in">console</span>.error(colno);<br>  <span class="hljs-built_in">console</span>.error(error);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在MVVM框架中使用onerror监听全局异常会发现并不能捕获到绑定事件的详细错误信息，只会输出Script Error，</p><p>这时我们可以尝试进入webpack配置，设置<code>devtool:&quot;source-map&quot;</code>,这时在控制台再次打印可以看见成功捕获到绑定事件的错误。</p><h3 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h3><p>两种主流上报方式：</p><ol><li><p>通过Ajax发送数据</p><p>因为Ajax请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建img标签的形式进行上报。</p></li><li><p>动态创建 img 标签的形式</p></li></ol><p><code>new Image().src = reportUrl + &#39;?msg=&#39; + msg;</code></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>错误处理</tag>
      
      <tag>错误上报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github高星的学习库</title>
    <link href="/2021/05/07/github%E9%AB%98%E6%98%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%BA%93/"/>
    <url>/2021/05/07/github%E9%AB%98%E6%98%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前端技术的变与不变"><a href="#前端技术的变与不变" class="headerlink" title="前端技术的变与不变"></a>前端技术的变与不变</h1><p>记录一些优质的github 学习资源。下面的都是一些前端领域极为优秀的学习资源。众所周知前端技术变化很快，但是我认为变的技术形态，不变的才是一个语言的核心。有空就翻翻这些优秀的库，巩固语言底层原理。掌握语言核心，轻松应对技术变化。</p><h1 id="优秀资源一览"><a href="#优秀资源一览" class="headerlink" title="优秀资源一览"></a>优秀资源一览</h1><h3 id="仓库1-JavaScript算法和数据结构"><a href="#仓库1-JavaScript算法和数据结构" class="headerlink" title="仓库1- JavaScript算法和数据结构"></a><span style="color: #faa043">仓库1- JavaScript算法和数据结构</span></h3><p>  <strong>star数： 106k</strong><br>  英文名：javascript-algorithms &amp; Data Structures 2020年 增长31.9K<br>  仓库地址：<a href="https://github.com/trekhleb/javascript-algorithms">https://github.com/trekhleb/javascript-algorithms</a><br>  <img src="https://files.catbox.moe/dgomf2.png" title="JavaScript算法和数据结构作者"><br>  该仓库包含了多种基于JavaScript的算法与数据结构。每种算法和数据结构都有自己的README，包含相关说明和链接，项目贴心的为你准备了中文版</p><p>  本，照顾英文不好的小伙伴。最主要的是还有相关的YouTube视频。</p><p>  YouTuBe视频地址:</p><p>  <a href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8</a></p><p>  就可以学习这些视频了，这些视频和仓库的学习资料一直在维护更新中，不用怕学到过时的知识。</p><h3 id="仓库2-Node-js最佳实践"><a href="#仓库2-Node-js最佳实践" class="headerlink" title="仓库2-Node.js最佳实践"></a><span style="color: #faa043">仓库2-Node.js最佳实践</span></h3><p>  <strong>star数 65k</strong><br>  英文名：Node bestpractices ，2020年增长 20.2k<br>  仓库地址：<a href="https://github.com/goldbergyoni/nodebestpractices">https://github.com/goldbergyoni/nodebestpractices</a><br><img src="https://files.catbox.moe/3d4t00.png" title="nodejs 最佳实践"><br>  这个算是Github上在Node.js 最佳实践 中排名最高的内容的总结和分享。</p><p>  他算是一个搜集总结，里边包括：项目结构实践、异常处理实践、编码规范实践、测试和总体质量实践、进入生产实践和安全实践。</p><p>  里边的内容一直都在更新，每周都有所增长，如果你想学习Node.js一定要关注这个仓库。</p><h3 id="仓库3-你不知道的JS"><a href="#仓库3-你不知道的JS" class="headerlink" title="仓库3-你不知道的JS"></a><span style="color: #faa043">仓库3-你不知道的JS</span></h3><p>  英文名：You-Dont-Know-JS , 2020年18K</p><p>  仓库地址:<a href="https://github.com/getify/You-Dont-Know-JS">https://github.com/getify/You-Dont-Know-JS</a></p><p>  <img src="https://files.catbox.moe/zn5hmm.png" title="你不知道的JS"><br>  如果你是一个前端，这本书是必看的，因为很多面试问题都会从这本书上出。我在这里简单举几个例子，比如什么是闭包、如何处理异步性能、作用域的相关知识…..熟读并掌握是最基本的要求了。</p><h3 id="仓库4-JavaScript代码整洁之道"><a href="#仓库4-JavaScript代码整洁之道" class="headerlink" title="仓库4- JavaScript代码整洁之道"></a><span style="color: #faa043">仓库4- JavaScript代码整洁之道</span></h3><p>  英文名：clean-code-javascript ， 年增长15.1K</p><p>  仓库地址：<a href="https://github.com/ryanmcdermott/clean-code-javascript">https://github.com/ryanmcdermott/clean-code-javascript</a><br>  <img src="https://files.catbox.moe/k2zffm.png" title="JavaScript代码整洁之道"><br>  这个项目的目的就是教会你如何写出更好的JavaScript代码，可以让人读懂的JavaScript代码。如果你已经是一名前端程序员，你会知道在实际开发中，我们阅读代码的时间会远远超过编写代码的时间，因此保证代码的可读性非常重要。</p><h3 id="仓库5-30秒代码"><a href="#仓库5-30秒代码" class="headerlink" title="仓库5-30秒代码"></a><span style="color: #faa043">仓库5-30秒代码</span></h3><p>  英文名：30 seconds of code ,年增长13.3K</p><p>  仓库地址：<a href="https://github.com/30-seconds/30-seconds-of-code">https://github.com/30-seconds/30-seconds-of-code</a><br>  <img src="https://files.catbox.moe/lb85ek.png" title="5-30秒代码"></p><p>  该项目里边都是开发时常用的简短代码，我开发时也经常从这里进行搬砖。更重要的是里边的代码编写的很经典。</p><p>  仓库把JavaScript代码按类别进行区分：数组、浏览器、日期、方法、计算、Node、对象和字符串类型，方便你平时使用的查找和学习。</p><p>  有些人为什么写的代码又快又好?也许并不是因为他单身多年，每日精进手速。往往只是知道一些你不知道的资源，这个项目就应该属于这一类型。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span style="color: #faa043">总结</span></h3><p>  编程这一行发展速度太快，每个月都有新的技术产生，不学习就会被淘汰。我因学习而焦虑，也因学习而充实。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习资源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端学习资源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识AST(抽象语法树)</title>
    <link href="/2021/05/07/%E5%AD%A6%E4%B9%A0AST-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"/>
    <url>/2021/05/07/%E5%AD%A6%E4%B9%A0AST-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="学习抽象语法树AST"><a href="#学习抽象语法树AST" class="headerlink" title="学习抽象语法树AST"></a>学习抽象语法树AST</h1><h2 id="AST概念"><a href="#AST概念" class="headerlink" title="AST概念"></a>AST概念</h2><blockquote><p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法架构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真是语法中出现的每个细节。比如嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；二类似于 if-condition-then这样的条件跳转语句，可以使用带有三个分支的节点来表示。<br>和抽象语法树相对的是具体语法树（通常称作分析树）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树，然后从分析树生成AST。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p></blockquote><p><img src="https://files.catbox.moe/y4ps45.png"></p><p>接下来我们将从概念性了解然后从一个实例中去一点点探索AST的神秘面纱</p><h2 id="什么是抽象语法树"><a href="#什么是抽象语法树" class="headerlink" title="什么是抽象语法树"></a>什么是抽象语法树</h2><p>在传统的编译语言的流程中，程序的一段源代码在执行之前会经历三个步骤,统称为<code>编译</code>:</p><ul><li>分词/词法分析阶段<br>这个过程会将由字符组成的字符串分解成有意义的代码块,这些代码块统称为词法单元(token).<br>举个例子: let a = 1,<br>这段程序通常会被分解成为下面这些词法单元:<br>let 、a、=、1、；<br>空格是否被当成此法单元，取决于空格在这门语言中的意义。</li><li>解析/语法分析<br>这个过程是将词法单元流转换成一个由元素嵌套所组成的代表了程序语法结构的树,这个树被称为<code>抽象语法树（abstract syntax code，AST)</code></li><li>代码生成<br>将AST转换成可执行代码的过程被称为代码生成.</li></ul><p>简单理解,就是把我们写的代码按照一定的规则转换成一种树形结构。<br>你可以到这个神奇的网站上看一下具体是如何转换成的<a href="https://astexplorer.net/">astexplorer</a><br><img src="https://files.catbox.moe/x4d0qa.png" alt="astexplorer" title="在线AST语法转换"></p><h2 id="AST的用途"><a href="#AST的用途" class="headerlink" title="AST的用途"></a>AST的用途</h2><p>AST的作用不仅仅是用来在JavaScript引擎的编译上，我们在实际的开发过程中也是经常使用的，比如我们常用的babel插件将 ES6转化成ES5、使用 UglifyJS来压缩代码 、css预处理器、开发WebPack插件、Vue-cli前端自动化工具等等，这些底层原理都是基于AST来实现的，AST能力十分强大， 能够帮助开发者理解JavaScript这门语言的精髓。</p><h2 id="AST的基础结构"><a href="#AST的基础结构" class="headerlink" title="AST的基础结构"></a>AST的基础结构</h2><p>我们在这个<a href="https://astexplorer.net/">在线转译AST</a> 的网址上输入一行简单的代码看一下</p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;jack&#x27;</span><br></code></pre></div></td></tr></table></figure><p>可以看到右边的转换后的AST结构是如下这样的<br><img src="https://files.catbox.moe/lpatwf.png" alt="转换后的AST"><br>json形式是这样的</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>  <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-number">199</span>,<br>  <span class="hljs-attr">&quot;body&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;VariableDeclaration&quot;</span>,<br>      <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-number">180</span>,<br>      <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-number">199</span>,<br>      <span class="hljs-attr">&quot;declarations&quot;</span>: [<br>        &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;VariableDeclarator&quot;</span>,<br>          <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-number">186</span>,<br>          <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-number">199</span>,<br>          <span class="hljs-attr">&quot;id&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;Identifier&quot;</span>,<br>            <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-number">186</span>,<br>            <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-number">190</span>,<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;name&quot;</span><br>          &#125;,<br>          <span class="hljs-attr">&quot;init&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;Literal&quot;</span>,<br>            <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-number">193</span>,<br>            <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-number">199</span>,<br>            <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;jack&quot;</span>,<br>            <span class="hljs-attr">&quot;raw&quot;</span>: <span class="hljs-string">&quot;&#x27;jack&#x27;&quot;</span><br>          &#125;<br>        &#125;<br>      ],<br>      <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;const&quot;</span><br>    &#125;<br>  ],<br>  <span class="hljs-attr">&quot;sourceType&quot;</span>: <span class="hljs-string">&quot;module&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以看到，一个标准的AST结构可以理解为一个json对象，那我们就可以通过一些方法去解析和操作它</p><h2 id="AST的编译过程"><a href="#AST的编译过程" class="headerlink" title="AST的编译过程"></a>AST的编译过程</h2><p>基本上AST的编译阶段如下<br><img src="https://files.catbox.moe/vla2lw.png" alt="AST编译阶段流程" title="AST编译阶段流程"></p><p>大致分为四个阶段</p><ol><li><p>词法分析scanner</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;jack&quot;</span><br></code></pre></div></td></tr></table></figure><p>在执行以上的代码时，在词法分析阶段，会对整段的代码进行扫描，生产tokens流<br>具体的tokens 流你可以在这个网址上看到<a href="https://esprima.org/demo/parse.html#">Esprima</a><br>如下图<br><img src="https://files.catbox.moe/j8zz67.png" alt="转化的tokens流" title="scanner扫描转化tokens流"></p></li><li><p>parser 生产AST<br>我们以上边的代码为例子，我们使用node 跑一下 感受下相关过程<br>首先初始化一个文件目录</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">mkdir</span> AST-<span class="hljs-keyword">test</span><br><span class="hljs-comment">// 进入目录</span><br><span class="hljs-keyword">cd</span>  AST-<span class="hljs-keyword">test</span><br><span class="hljs-comment">// 初始化一个node项目</span><br>npm init -y<br><span class="hljs-comment">// 这里我们使用esproma 去生成 首先安装相关依赖 命令行执行如下</span><br>npm i esprima --<span class="hljs-keyword">save</span><br><span class="hljs-comment">// 执行命令</span><br></code></pre></div></td></tr></table></figure><p>然后新建一个index.js 文件  并写入如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 新建文件</span><br>touch index.js<br><span class="hljs-comment">// 把如下代码写入index.js</span><br><span class="hljs-keyword">const</span> esproma = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esprima&#x27;</span>);<br><span class="hljs-keyword">let</span> code = <span class="hljs-string">&#x27;const name = &quot;jack&quot;&#x27;</span>;<br><span class="hljs-keyword">const</span> ast = esproma.parse(code);<br><span class="hljs-built_in">console</span>.log(ast);<br></code></pre></div></td></tr></table></figure><p>执行index.js<br>node index.js<br>输出了如下的代码</p></li></ol><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">Script &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-symbol">&#x27;Program</span>&#x27;,<br>  <span class="hljs-keyword">body</span>: [<br>    VariableDeclaration &#123;<br>      <span class="hljs-keyword">type</span>: <span class="hljs-symbol">&#x27;VariableDeclaration</span>&#x27;,<br>      declarations: [<span class="hljs-keyword">Array</span>],<br>      kind: <span class="hljs-symbol">&#x27;const</span>&#x27;<br>    &#125;<br>  ],<br>  sourceType: <span class="hljs-symbol">&#x27;script</span>&#x27;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们现在就得到了一棵AST树</p><ol start="3"><li>traverse对AST树遍历,进行增删改查<br>这里使用estraverse去完成, 安装相关依赖 npm i estraverse –save<br>我们试着把上边的代码更改为<strong>const author = “mills han”</strong><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> esproma = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esprima&#x27;</span>);<br><span class="hljs-keyword">const</span> estraverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;estraverse&#x27;</span>);<br><span class="hljs-keyword">let</span> code = <span class="hljs-string">&#x27;const name = &quot;jack&quot;&#x27;</span>;<br><span class="hljs-keyword">const</span> ast = esproma.parse(code);<br>estraverse.traverse(ast, &#123;<br>  enter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>&#123;<br>    <span class="hljs-comment">// 更改代码</span><br>    node.name = <span class="hljs-string">&#x27;author&#x27;</span>;<br>    node.value = <span class="hljs-string">&#x27;mills han&#x27;</span><br>  &#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(ast);<br></code></pre></div></td></tr></table></figure></li></ol><p> 运行结果如下<br> <figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">Script &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;Program&#x27;</span>,<br>  body: [<br>    VariableDeclaration &#123;<br>      <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;VariableDeclaration&#x27;</span>,<br>      declarations: [<span class="hljs-keyword">Array</span>],<br>      kind: <span class="hljs-string">&#x27;const&#x27;</span>,<br>      <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;author&#x27;</span>,<br>      <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;mills han&#x27;</span><br>    &#125;<br>  ],<br>  sourceType: <span class="hljs-string">&#x27;script&#x27;</span>,<br>  <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;author&#x27;</span>,<br>  <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;mills han&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><br> 我们再执行的过程中就对原来的代码完成了遍历更新<br>4. generator将更新后的AST转化成代码<br>  这里我们使用escodegen去生成, 安装相关依赖 npm i escodegen –save<br>  在原来的代码基础上添加如下<br>  <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> escodegen = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;escodegen&#x27;</span>);<br><span class="hljs-comment">// codegen</span><br><span class="hljs-keyword">const</span> transformedCode = escodegen.generate(ast);<br><span class="hljs-built_in">console</span>.log(transformedCode);<br></code></pre></div></td></tr></table></figure></p><p>  输出如下<br>  <figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta">$ node <span class="hljs-keyword">index</span>.js<br><span class="hljs-keyword">const</span> author = <span class="hljs-string">&#x27;mills han&#x27;</span>;<br></code></pre></div></td></tr></table></figure><br>  好了！我们完成了对一段简单代码的AST编译过程</p><h2 id="AST在业务中的应用"><a href="#AST在业务中的应用" class="headerlink" title="AST在业务中的应用"></a>AST在业务中的应用</h2><p>  当前很多第三方的包依赖都会用到AST. 比如鼎鼎大名的 <strong>Babel</strong> </p><ul><li><a href="https://www.babeljs.cn/">Babel</a>是一个JavaScript的代码转换器，能把JavaScript的最新语法转译成浏览器兼容的语法。<br>Babel的三个主要处理步骤分别是： <strong>解析（parse），转换（transform），生成（generate）</strong>。</li><li>Vue.js<br>Vue.js 在它的编译模板过程中也会用到AST</li><li>等等其他</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>  AST抽象语法树的知识点作为JavaScript中(任何编程语言中都有ast这个概念,这里就不过多赘述)相对基础的，也是最不可忽略的知识，带给我们的启发是无限可能的，它就像一把螺丝刀，能够拆解javascript这台庞大的机器，让我们能够看到一些本质的东西，同时也能通过它批量构建任何javascript代码。</p>]]></content>
    
    
    <categories>
      
      <category>AST</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DevTools调试技巧之快捷键</title>
    <link href="/2021/04/25/Chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/04/25/Chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>能直接提升开发调试效率的技巧是什么？</p><ul><li>掌握快捷键</li></ul><p>这是一些在日常调试中最常用的一些快捷键方法</p><h2 id="1-切换dev-Toos-布局窗口"><a href="#1-切换dev-Toos-布局窗口" class="headerlink" title="1.切换dev Toos 布局窗口"></a>1.切换dev Toos 布局窗口</h2><p>一般我在使用 DevTools 时， dock 的展示窗口都在底部 ，但是有时候我想把 dock 的窗口 切换到右边。</p><p>怎么做呢？</p><p>这时就可以通过 DevTools 的下拉菜单，或者命令菜单…或者使用一个快捷键 <font color=HotPink>ctrl + shift + D (⌘ + shift + D Mac)</font>来实现位置的切换（通常是从 开始的位置 到 右边位置， 但是如果一开始就是 右边的位置 那么会切换到 左边的位置）:<br><img src="https://user-gold-cdn.xitu.io/2018/12/18/167c07cf50125757?imageslim" alt="Chrome 切换调试布局" title="快速切换布局方式示意图"></p><h2 id="2-快速切换面板栏"><a href="#2-快速切换面板栏" class="headerlink" title="2.快速切换面板栏"></a>2.快速切换面板栏</h2><p>如果我们想快速的从console面板切换到elements面板，如何操作呢？</p><ul><li><p>按下<font color="Hotpink"> ctrl + [</font> 和 <font color="Hotpink"> ctrl + ]</font>可以从当前面板的分别向左和向右切换面板。</p></li><li><p>按下<font color="Hotpink">ctrl + 1</font> 到<font color="Hotpink">ctrl + 9</font>可以直接转到编号1…9的面板(ctrl + 1转到元素面板，ctrl + 4` 转到 网络信息面板等等)<br><img src="https://user-gold-cdn.xitu.io/2018/12/18/167c07cf4d56febf?imageslim" title="快速切换面板示意图"></p></li></ul><blockquote><p>请注意! 我们在上面介绍的快捷键方式默认被禁用了。你可以通过 DevTools&gt;&gt;Settings &gt;&gt;Preferences&gt;&gt;<em>Appearance</em> 打开这个选项：</p></blockquote><blockquote><p>如果不设置的话，这个快捷键方式默认切换的window的tab</p></blockquote><h2 id="3-递增-递减"><a href="#3-递增-递减" class="headerlink" title="3.递增/递减"></a>3.递增/递减</h2><p>接下来这个技巧，对调整样式是最有用的：通过使用 带有 或者 不带有修饰键 的 上 / 下 箭头按键， 你可以实现递增和递减 0.1 ， 1 或者 10 这样数值类型的值。<br><img src="https://user-gold-cdn.xitu.io/2018/12/18/167c07cf43b2f06e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>甚至对颜色都起作用！（虽然没什么卵用，但是真的可以起作用~）</p><h2 id="4-elements，-logs，-sources-amp-network-中的查找"><a href="#4-elements，-logs，-sources-amp-network-中的查找" class="headerlink" title="4.elements， logs， sources &amp; network 中的查找"></a>4.elements， logs， sources &amp; network 中的查找</h2><p>DevTools 中的前4个主要的面板，每一个都支持<font color="Hotpink">[ctrl] + [f]</font>快捷方式，你可以使用对应的查询方式来查找信息:</p><ul><li>在 Elements 面板中 - 通过 string ，选择器 或者 XPath 来查找</li><li>而在 Console， Network 以及 Source 面板 - 通过区分大小写，或者可以被视为表达式的 strings， 来查找</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/168747e72320ff3a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" title="search 的高级用法"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识Chrome-DevTools</title>
    <link href="/2021/04/21/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20Chrome%20%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/04/21/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20Chrome%20%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Chrome-DevToos"><a href="#Chrome-DevToos" class="headerlink" title="Chrome DevToos"></a>Chrome DevToos</h1><p>Chrome 是当今世界上使用最流行的浏览器<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827348caaefb08?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Chrome浏览器" title="浏览器使用率"></p><p>对于大部分人来说，Chrome 可能只是个浏览器，但是对于开发人员来说，它更是一个强大无比的工具，为了方便开发人员调试代码，主流的浏览器都内置了 DevTools， 身为一个天天跟浏览器打交道的前端攻城狮，熟悉浏览器调试是基本操作之一，掌握 Chrome 的调试技巧意味着效率直接的提高。</p><h3 id="如何打开Chrome-DevToos"><a href="#如何打开Chrome-DevToos" class="headerlink" title="如何打开Chrome DevToos"></a>如何打开Chrome DevToos</h3><ul><li><p>在 Chrome 菜单中选择 更多工具 &gt; 开发者工具</p></li><li><p>在页面元素上右键点击，选择 “检查”</p></li><li><p>使用 快捷键 Ctrl + Shift + I (Windows) 或 Cmd + Opt + I (Mac)</p></li></ul><h3 id="8大功能面板"><a href="#8大功能面板" class="headerlink" title="8大功能面板"></a>8大功能面板</h3><ol><li>元素面板</li><li>控制台面板</li><li>源代码面板</li><li>网络面板</li><li>性能面板</li><li>内存面板</li><li>应用面板</li><li>安全面板</li></ol><h4 id="1-element-元素面板"><a href="#1-element-元素面板" class="headerlink" title="1. element 元素面板"></a>1. element 元素面板</h4><p>调试DOM 元素 和css 样式来迭代布局和设计页面</p><ul><li>编辑DOM</li><li>编辑CSS样式</li><li>检查和调试样式</li></ul><p><img src="https://files.catbox.moe/bibmsn.png" alt="Elements面板" title="Elements面板"></p><h4 id="1-Console-控制台面板"><a href="#1-Console-控制台面板" class="headerlink" title="1. Console 控制台面板"></a>1. Console 控制台面板</h4><p>直接可以在上边运行代码段，在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为 shell 在页面上与 JavaScript 交互。<br><img src="https://files.catbox.moe/5l0bfo.png" alt="Console 面板" title="Console 面板"></p><h4 id="3-源代码面板"><a href="#3-源代码面板" class="headerlink" title="3.源代码面板"></a>3.源代码面板</h4><p>在源代码面板中设置断点来调试 JavaScript ，或者通过 Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器</p><ul><li>断点调试</li><li>调试混淆的代码</li><li>使用开发者工具的 Workspaces（工作区）进行持久化保存<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827446443e67ff?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="断点调试" title="断点调试"></li></ul><h4 id="4-网络面板"><a href="#4-网络面板" class="headerlink" title="4.网络面板"></a>4.网络面板</h4><p>使用网络面板了解请求和下载的资源文件并优化网页加载性能。</p><ul><li>网络面板基础</li><li>了解资源时间轴</li><li>网络带宽限制<br><img src="https://files.catbox.moe/ww07z7.png" alt="网络面板" title="网络面板"></li></ul><h4 id="5-性能面板"><a href="#5-性能面板" class="headerlink" title="5.性能面板"></a>5.性能面板</h4><p>使用时间轴面板可以通过记录和查看网站生命周期内发生的各种事件来提高页面的运行时性能。<br><img src="https://files.catbox.moe/m8h8y4.png" alt="性能面板图" title="性能面板"></p><h4 id="6-内存面板"><a href="#6-内存面板" class="headerlink" title="6.内存面板"></a>6.内存面板</h4><p>如果需要比时间轴面板提供的更多信息，可以使用“配置”面板，例如跟踪内存泄漏。</p><p>JavaScript CPU 分析器<br>内存堆区分析器<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827446210a9e18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h4 id="7-应用面板"><a href="#7-应用面板" class="headerlink" title="7.应用面板"></a>7.应用面板</h4><p>使用资源面板检查加载的所有资源，包括 IndexedDB 与 Web SQL 数据库，本地和会话存储，cookie ，应用程序缓存，图像，字体和样式表。</p><ul><li>管理数据<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827446eff22017?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></li></ul><h4 id="8-安全面板"><a href="#8-安全面板" class="headerlink" title="8.安全面板"></a>8.安全面板</h4><p>使用安全面板调试混合内容问题，证书问题等等。</p><p>安全<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827447112db421?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
